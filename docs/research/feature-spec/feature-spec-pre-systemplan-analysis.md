# `/feature-spec` Pre-`/system-plan` Analysis
**Date:** 2026-02-22  
**Status:** Ready to guide `/system-plan` run  
**Scope:** Risk analysis, install validation, architectural refinements, Graphiti integration opportunities

---

## 1. Slash Command Location — CONFIRMED ✅

### What the installer actually does

The `install.sh` creates this structure:

```
~/.agentecflow/
└── commands/       ← all global commands live here
    ├── system-plan.md
    ├── feature-plan.md
    └── ...

~/.claude/
└── commands → ~/.agentecflow/commands   ← symlink created by setup_claude_integration()
```

Claude Code picks up slash commands from `~/.claude/commands` (via the symlink) **and** from the project-local `.claude/commands/`.

### For `feature-spec.md` — there are two valid options:

| Option | Path | Scope | When to use |
|--------|------|-------|-------------|
| **Project-local** | `.claude/commands/feature-spec.md` | This repo only, when developing in GuardKit | Correct for the GuardKit project during development |
| **Global install** | `installer/core/commands/feature-spec.md` | Available in every project after `install.sh` | Correct when releasing `/feature-spec` as a GuardKit feature for end-users |

The spec's proposed path of `.guardkit/commands/feature-spec.md` is **invalid** on both counts — there is no `commands/` directory in `.guardkit/` and no mechanism reads from there.

### Corrected paths for Task 4

The spec must be updated to:
- **For development/dogfooding now:** `.claude/commands/feature-spec.md`  
- **For release:** `installer/core/commands/feature-spec.md` (added to the installer, deployed globally)

Given the pattern the other commands follow — they're all in `.claude/commands/` in this repo and deployed via the installer — `feature-spec.md` should follow the same path. Add it to both `.claude/commands/` (project-local) and `installer/core/commands/` (for global distribution) in the same way `system-plan.md`, `feature-plan.md`, etc. are managed.

---

## 2. Learnings from `/generate-bdd` Before Retiring It

`/generate-bdd` exists today at `.claude/commands/generate-bdd.md`. When RequireKit is retired this command loses its raison d'être (it converts EARS notation → Gherkin, and EARS comes from RequireKit). The following are worth preserving in `/feature-spec`:

### What `/generate-bdd` does well

**Tag taxonomy** — it has a clear, consistent tagging system that maps to test suite organisation:
```gherkin
@requirement-REQ-XXX  @happy-path  @smoke  @regression  @api
```
`/feature-spec`'s category tags (`@key-example`, `@boundary`, `@negative`, `@edge-case`) are better aligned to Specification by Example, but the `@smoke` and `@regression` cross-cutting tags from `/generate-bdd` are genuinely useful for AutoBuild's Coach when deciding which tests to run for a given task type. **Recommendation:** retain `@smoke` and `@regression` tags in `/feature-spec`'s Gherkin output, generated from the Key Examples category.

**EARS transformation patterns** — the explicit mappings (Event-Driven → Given/When/Then, State-Driven → scenario with state, Unwanted Behavior → error scenario) are well-articulated. These are good guard rails for the methodology prompt. `/feature-spec`'s slash command should encode these same structural mappings even though it receives loose input instead of formal EARS.

**Background blocks** — `/generate-bdd` consistently generates `Background:` sections with setup state. `/feature-spec` should make this equally systematic: Background captures the preconditions shared across all scenarios. The spec doesn't currently mention Background generation explicitly.

**`Scenario Outline` with `Examples` tables** — already in both specs. Keep.

**Output directory convention** — `/generate-bdd` uses `docs/bdd/features/`. The `/feature-spec` spec proposes `features/` at repo root. Keep `features/` (it's cleaner), but note this in the slash command so the Player doesn't create `docs/bdd/` by accident.

### What `/generate-bdd` gets wrong (don't replicate)

- Output includes implementation hints embedded in Gherkin comments (`# Implementation: tests/e2e/auth.spec.ts::testLogin`). This couples the spec to implementation, violating D10 (domain language). Do not carry this pattern into `/feature-spec`.
- No assumptions tracking — every inferred behaviour is silent. This is the core problem `/feature-spec` fixes with the assumptions manifest.
- No interactive review — it generates and dumps. The propose-review cycle is `/feature-spec`'s key improvement.

### Migration note for the slash command

Add a note to `.claude/commands/feature-spec.md`:

> If you have existing `.feature` files generated by `/generate-bdd`, `/feature-spec` detects them during context gathering (Phase 1) and avoids generating contradictory scenarios.

---

## 3. Stack Detector — Refined for GuardKit Reality

### Why GuardKit appears polyglot

GuardKit has `tsconfig.json` and `vitest.config.ts` at the repo root. Checking what these actually configure:

- `vitest.config.ts` — likely drives the TypeScript integration tests in `tests/integration/figma-to-react-workflow.test.ts` and `tests/integration/zeplin-to-maui-workflow.test.ts`. These are test harnesses for validating template output, not production code.
- `package.json` / `tsconfig.json` — similarly, these support the TypeScript test infrastructure.
- The production package is `guardkit-py` (Python), registered at `pyproject.toml` with `packages = ["guardkit"]`.

**Recommendation:** Clean up by moving the TypeScript test config files into a `tests/integration/ts/` subdirectory (or similar). This eliminates the ambiguity at root level and makes `StackDetector`'s life easy. This is a low-risk tidying task that can be done before or alongside the `feature-spec` implementation.

### Refined StackDetector logic for `feature-spec` purposes

For v1, the detector does not need to be a sophisticated scoring system. Given GuardKit's actual structure, apply this simpler priority-based rule:

```
1. If pyproject.toml or setup.py exists at root → PYTHON (confidence: high)
2. If go.mod exists → GO
3. If package.json exists AND no pyproject.toml → TYPESCRIPT/NODE
4. Otherwise → GENERIC (no scaffolding)
```

Rule 1 wins for GuardKit even if `package.json` is also present, which correctly identifies it as a Python project.

**For the slash command invocation pattern inside GuardKit**, add a note in the methodology:

> When running `/feature-spec` inside the GuardKit repository itself, the detected stack will be Python. If you intend to spec a feature for a different target project's stack, use `--stack <target>` to override.

### The `tsconfig.json` / `vitest.config.ts` cleanup

This is worth doing independently as a small task:
- Move `vitest.config.ts` and associated TypeScript test config into `tests/integration/`
- Verify the TypeScript integration tests still run from their new location
- Update any import paths that reference the root-level config

This is a 30-minute task that prevents ongoing confusion and makes the repo's Python-first nature visually clear.

---

## 4. Additive Architecture — Existing Workflows Unaffected

This is the most important architectural constraint: **`/feature-plan` and AutoBuild must continue to work exactly as they do today when no Gherkin spec exists.**

### How this is guaranteed

The current AutoBuild context pipeline (`JobContextRetriever`) pulls from Graphiti group IDs:
- `feature_specs`
- `task_outcomes`
- `patterns_{tech_stack}`
- `project_architecture`
- `failure_patterns`
- `domain_knowledge`
- (autobuild-specific) `role_constraints`, `quality_gate_configs`, `turn_states`, `implementation_modes`

`/feature-spec` adds to `feature_specs`. If no `/feature-spec` has been run for a feature, that group simply returns no results for that feature — exactly as it does today for every feature currently in flight. The retriever handles empty results gracefully (returns `[]`). **No change to retrieval logic is needed.**

The `FeaturePlanContextBuilder.build_context()` already uses `_safe_search()` with graceful degradation. If the `feature_specs` group has no entry for a given FEAT-XXX, the context builds with `feature_spec = {}` and proceeds. This is the current behaviour.

### The only integration point that needs explicit design

`/feature-plan` currently generates tasks with acceptance criteria from the feature description. When a Gherkin `.feature` file exists (generated by `/feature-spec`), the `/feature-plan` slash command methodology should optionally read it to:

1. Map Gherkin scenarios → task acceptance criteria (concrete, BDD-formatted)
2. Carry assumption confidence levels from `_assumptions.yaml` into task metadata (for complexity scoring)

This is purely additive to the `/feature-plan` methodology file. The change is: if a `features/{name}/*.feature` file is found alongside the feature description, read it. If not found, proceed as normal. No Python code changes needed in the existing flow.

**What this means for Task 4:** The `feature-spec.md` slash command file must specify where it writes output. The output path convention must be one that `/feature-plan` can find deterministically (e.g., `features/{kebab-case-name}/`). The `.feature` file naming convention needs to be stable so `/feature-plan` can scan for it.

---

## 5. Tasks 1–3 Deferred to v2

Tasks 1–3 as specified produce five Python formatter modules (Gherkin validator, StackDetector, ScaffoldingGenerator, AssumptionsGenerator, FeatureSummaryGenerator). Per the recommendation to defer these to v2, the rationale and full planning is captured in the companion document:

**`docs/research/feature-spec/FEATURE-SPEC-v2-formatter-modules.md`**

See Section 6 below for the full v2 document content.

### What v1 does instead (Task 5, revised)

The orchestration module (`guardkit/commands/feature_spec.py`) for v1 is significantly simpler:

- **Stack detection:** A 10-line function checking for `pyproject.toml`, `go.mod`, `package.json` in that priority order. Returns a string: `"python"`, `"go"`, `"typescript"`, or `"generic"`. No class needed.
- **File I/O:** Write `.feature`, `_assumptions.yaml`, `_summary.md`, and scaffold files directly. No validator wrapping the output — trust Claude's generation.
- **Assumptions manifest:** Build a Python dict from the structured conversation output, serialize with `yaml.dump()`. pyyaml is already in `pyproject.toml`.
- **Feature summary:** Generate a markdown string inline. No class.

The Coach validates v1 output through integration tests (Task 6) that check the generated files exist, are valid YAML/Gherkin syntax (using `yaml.safe_load()` for the manifest), and contain expected sections.

### Revised v1 file tree

```
guardkit/
├── .claude/
│   └── commands/
│       └── feature-spec.md              # NEW — Task 4 (the methodology)
├── guardkit/
│   └── commands/
│       └── feature_spec.py              # NEW — Task 5 (simplified orchestration)
├── tests/
│   ├── test_feature_spec_command.py     # NEW — Task 5 unit tests
│   └── integration/
│       └── test_feature_spec_e2e.py     # NEW — Task 6
└── docs/
    └── commands/
        └── feature-spec.md              # NEW — Task 6 (user docs)
```

This is 3 new Python files (including test files) instead of 12. The surface area reduction is significant.

---

## 6. Graphiti Integration Opportunities

This is the highest-leverage area for improving overall system performance. The current Graphiti integration is solid but `feature-spec` creates several new opportunities.

### 6.1 What `/feature-spec` generates that Graphiti should know about

Currently, when a feature specification is created, the `FeaturePlanContextBuilder.seed_feature_spec()` seeds the feature spec into the `feature_specs` group. `/feature-spec` generates richer artefacts that enable three new seed targets:

**A. Gherkin Scenarios as Searchable Entities**

Individual Gherkin scenarios should be seeded as distinct episodes, not just the feature file as a blob. Each scenario is a named, tagged behavioural contract. When seeded individually, the Coach can later query: "What scenarios cover file upload validation?" and get back the specific scenarios — not just "the document upload feature exists."

Seed structure:
```yaml
group_id: feature_specs
entity_type: gherkin_scenario
episode: |
  {
    "feature_id": "FEAT-XXX",
    "scenario_name": "Reject file exceeding maximum size",
    "category": "boundary",
    "tags": ["boundary", "smoke"],
    "steps": [...],
    "assumptions": ["ASM-001"]
  }
```

**B. Assumptions as First-Class Knowledge Graph Nodes**

The `_assumptions.yaml` manifest contains structured uncertainty that belongs in Graphiti's `domain_knowledge` group. When seeded, future tasks in the same domain can retrieve: "What assumptions were made about file size limits in this project?" This prevents the same assumption being silently re-made in a different feature.

Seed structure:
```yaml
group_id: domain_knowledge
entity_type: assumption
episode: |
  {
    "assumption_id": "ASM-001",
    "feature_id": "FEAT-XXX",
    "text": "Maximum file size is 50MB",
    "confidence": "medium",
    "basis": "Common web application default",
    "status": "pending_human_review"
  }
```

When the human resolves an assumption (accepts/modifies), update the episode in place using `upsert_episode()`. If modified, the new value becomes the canonical fact for that domain.

**C. Specification Coverage Map**

A lightweight graph of which behaviours have been specified, by domain tag. This enables the Layer 4 gate (Graphiti Coverage Gating) — "low knowledge-graph coverage for this task's domain tags → pause before execution." Currently this gate is aspirational; seeding scenario coverage makes it implementable.

### 6.2 How seeding fits into the `/feature-spec` flow

Seeding happens at the end of Phase 6 (Output Generation), after files are written and the human has reviewed the assumptions. The slash command methodology should instruct:

> After writing output files, call the Python orchestration module's `seed_to_graphiti()` function. This seeds: (1) the feature spec overview to `feature_specs`, (2) individual scenarios to `feature_specs` as distinct episodes, (3) assumptions to `domain_knowledge`. If Graphiti is unavailable, log a warning and continue — seeding is non-blocking.

This is additive to `FeaturePlanContextBuilder.seed_feature_spec()` — extend it rather than replacing it.

### 6.3 Retrieval improvements enabled by `/feature-spec`

Once scenarios and assumptions are seeded, the existing `JobContextRetriever` gains without code changes:

| Context category | What improves |
|-----------------|---------------|
| `feature_specs` | Returns individual scenario episodes, not just feature blobs. The Coach gets specific Gherkin scenarios for the task being implemented — not the whole feature file. |
| `domain_knowledge` | Returns prior assumptions in the same domain. Player sees "in this project, file size limits are assumed to be 50MB unless specified otherwise." |
| `failure_patterns` | If an assumption is later marked as incorrect (implementation revealed wrong default), seed it as a failure pattern so future features don't repeat the same wrong assumption. |

### 6.4 The Coach validation improvement

The Coach currently validates code against acceptance criteria expressed as prose. When Gherkin scenarios are in Graphiti and retrieved as part of the AutoBuild task context, the Coach's validation prompt can be augmented:

> You have access to the Gherkin scenarios for this feature (retrieved from knowledge graph). For each scenario tagged `@smoke`, verify the Player's implementation handles it. For scenarios tagged with `[ASSUMPTION]`, verify the Player's assumption matches the one recorded in the assumptions manifest.

This is the concrete implementation of "Coach validates against Gherkin" that the spec describes but doesn't ground in mechanics. The mechanics are: Gherkin in Graphiti → retrieved via `feature_specs` group → injected into Coach context → Coach validates systematically.

### 6.5 ADRs to seed immediately after implementation

The three ADRs defined in the spec (ADR-FS-001, ADR-FS-002, ADR-FS-003) should be seeded to Graphiti in the `architecture_decisions` group using the existing `seed_architecture_decisions.py` pattern. The seeding commands in the spec already reference `guardkit graphiti add-context` — verify these map to the correct seeding functions in `guardkit/knowledge/seed_architecture_decisions.py`.

### 6.6 New `group_id` to add to `graphiti.yaml`

Add `gherkin_scenarios` and `spec_assumptions` as explicit group IDs:

```yaml
group_ids:
  - product_knowledge
  - command_workflows
  - architecture_decisions
  - gherkin_scenarios      # NEW — individual scenario episodes from /feature-spec
  - spec_assumptions       # NEW — structured assumption tracking
```

---

## 7. Corrected Spec: Key Changes for `/system-plan`

Before running `/system-plan`, apply these corrections to the spec:

| # | Change | File | Detail |
|---|--------|------|--------|
| 1 | Fix all `src/guardkit/` paths | FEATURE-SPEC v2 | Replace with `guardkit/` — no `src/` directory exists |
| 2 | Fix slash command path | Task 4 | `.guardkit/commands/` → `.claude/commands/` (and `installer/core/commands/` for global release) |
| 3 | Remove Tasks 1–3 from v1 scope | Task plan | Defer formatter modules to v2 (see companion document) |
| 4 | Simplify Task 5 | Task 5 | Orchestration module handles all file I/O inline; no formatter dependencies |
| 5 | Add `/feature-plan` integration note | Task 4 | Slash command must document output path so `/feature-plan` can scan for `.feature` files |
| 6 | Add Graphiti seeding to Task 5 | Task 5 | `seed_to_graphiti()` at end of Phase 6; seeds scenarios + assumptions |
| 7 | Add `@smoke`, `@regression` tags | Task 4 | Inherit from `/generate-bdd` tag taxonomy for Coach test selection |
| 8 | Add Background generation | Task 4 | Explicitly instruct AI to generate `Background:` sections |
| 9 | Fix templates collision | Task 2 (deferred) | When v2 implements, use `guardkit/formatters/templates/` not `guardkit/templates/bdd/` to avoid collision with existing Jinja2 templates |
| 10 | pyyaml not a new dependency | Task 5 | Already in `pyproject.toml` — no `pyproject.toml` changes needed |

---

## 8. Revised v1 Task Summary

| Task | Scope | Complexity | Changes from original |
|------|-------|------------|----------------------|
| Task 1 | Gherkin formatter module | Deferred to v2 | — |
| Task 2 | Stack detector + scaffolding | Deferred to v2 | — |
| Task 3 | Assumptions + summary generators | Deferred to v2 | — |
| **Task 4** | **`/feature-spec` slash command** | **High** | **Path: `.claude/commands/feature-spec.md`. Add: Background generation, @smoke/@regression tags, output path convention for /feature-plan interop** |
| **Task 5** | **Orchestration module** | **Medium** | **Simplified: inline stack detection (10 lines), inline file I/O, inline YAML/markdown generation, `seed_to_graphiti()` call at end** |
| **Task 6** | **Integration tests + docs** | **Medium** | **Unchanged in scope; tests validate the simplified pipeline** |

---

## Companion Document Reference

The full v2 planning and knowledge preservation for Tasks 1–3 is in:
```
docs/research/feature-spec/FEATURE-SPEC-v2-formatter-modules.md
```
See next section.
