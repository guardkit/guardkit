---
id: TASK-IC-DD44
title: Add consumer_context metadata and seam test stub generation to feature-plan
status: completed
created: 2026-02-18T00:00:00Z
updated: 2026-02-19T00:00:00Z
completed: 2026-02-19T00:00:00Z
completed_location: tasks/completed/TASK-IC-DD44/
previous_state: in_review
state_transition_reason: "Task completed - all acceptance criteria met"
priority: high
task_type: feature
parent_feature: TASK-FP-1B6D
parent_review: TASK-REV-0E07
complexity: 5
dependencies:
  - TASK-IC-6F94  # Child A must be complete first — seam tests are generated from integration contracts
related_tasks:
  - TASK-IC-6F94  # Child A (prerequisite)
  - TASK-IC-B4E6  # Child C (depends on this)
  - TASK-FP-1B6D  # Superseded parent task (do not work on)
tags: [feature-plan, consumer-context, seam-tests, coach-validator, autobuild]
---

# Add consumer_context Metadata and Seam Test Stub Generation to feature-plan

## Context

This is Child B of the TASK-FP-1B6D decomposition. It depends on TASK-IC-6F94 (Child A) being complete — the integration contracts generated by Child A are the source of the `consumer_context` metadata and seam test stubs produced here.

Changes 2 and 3 from the original TASK-FP-1B6D analysis are grouped together because they are tightly coupled: seam test stubs are generated from the `consumer_context` data, so they share the same data model and generation point in the feature planner.

## Changes Required

### Change 2: Add `consumer_context` to infrastructure task metadata

**What:** When the feature planner generates an infrastructure task (one that produces environment variables, connection strings, or config artifacts consumed by another task), it must include a `consumer_context` block in the task's YAML frontmatter.

**Schema to add to infrastructure task frontmatter:**

```yaml
consumer_context:
  - task: TASK-DB-xxx           # The consuming task ID
    consumes: DATABASE_URL       # The artifact key being consumed
    framework: "SQLAlchemy async (create_async_engine)"  # Consumer framework description
    driver: "asyncpg"            # Specific driver/library
    format_note: "URL must include +asyncpg dialect suffix for async engine"
```

**Where it lives:** The feature planner prompt (in `feature-plan.md`, §3 task generation instructions) must instruct the AI to add `consumer_context` to infrastructure tasks whenever an Integration Contract (§4) has been generated for that task's output.

**Coach validator update:** `guardkit/orchestrator/quality_gates/coach_validator.py` must be updated to:
1. Read `consumer_context` from the task's frontmatter (if present)
2. For each consumer entry, verify the produced artifact's format matches the declared `format_note` constraint
3. Report format mismatches explicitly as a validation failure — not just "artifact is present"

The Coach does NOT need framework-specific knowledge. It only needs to check that the produced artifact string matches the pattern/prefix implied by `format_note`. The intelligence lives in the contract, not in the validator.

### Change 3: Generate seam test stubs from integration contracts

**What:** When `/feature-plan` generates an Integration Contract (§4), it must also generate a seam test stub in the consuming task's test scaffolding.

**Stub template (auto-generated):**

```python
# Auto-generated from Integration Contract: {artifact_name}
# Producer: {producer_task} | Consumer: {consumer_task}
# See: Integration Contracts section of the feature plan

import pytest

@pytest.mark.seam
@pytest.mark.integration_contract("{artifact_name}")
def test_infrastructure_output_compatible_with_consumer():
    """
    Verify that the infrastructure task's output artifact
    is consumable by the downstream task's framework.

    Contract: {format_note}
    """
    # Producer side: get the artifact
    artifact = get_env_exports("{service_name}")["{artifact_key}"]

    # Consumer side: verify the framework accepts it
    # TODO: Fill in framework-specific validation
    assert validate_connection_url_for_consumer(artifact), (
        f"Infrastructure artifact '{{artifact}}' is not compatible "
        f"with the declared consumer framework. Expected format: {format_note}"
    )
```

**Key design:** The seam test is generated from the integration contract data, not written manually. The Player (implementer of the consuming task) fills in `validate_connection_url_for_consumer` with a framework-appropriate call (e.g. `create_async_engine(artifact)`). The test skeleton already exists and must pass — the implementer cannot forget it.

**Where stubs are placed:** In the consuming task's generated task file, under a `## Seam Tests` section, as a code block the implementer must copy into the test suite. If the project already has a test directory, they go into `tests/seam/`.

## Acceptance Criteria

- [x] Infrastructure tasks generated by `/feature-plan` include `consumer_context` YAML frontmatter when they have a corresponding Integration Contract
- [x] `consumer_context` schema matches the template above (task, consumes, framework, driver, format_note)
- [x] `coach_validator.py` reads `consumer_context` and validates artifact format against `format_note` (not just artifact existence)
- [x] Coach validation failure message when format mismatch detected is explicit: includes the artifact value, the expected format, and the consumer task ID
- [x] Consuming tasks generated by `/feature-plan` include a `## Seam Tests` section with the generated stub when a contract exists for their input artifact
- [x] **Verification test:** Generate a feature plan for `"Add PostgreSQL database integration using SQLAlchemy async"`. Confirm:
  - The Docker infrastructure task has `consumer_context` with `format_note: "URL must include +asyncpg dialect suffix"`
  - The database layer task has a `## Seam Tests` section with the stub
  - The Coach (when validating the infrastructure task) flags `postgresql://` as a format mismatch and passes `postgresql+asyncpg://`

## Constraints

- The Coach validator must not contain SQLAlchemy, asyncpg, or any other framework-specific knowledge — format validation must be string-pattern matching against the `format_note` from the contract
- Seam test stubs MUST be generated as prompt output in the feature planner, not as a separate Python module. The feature planner already generates task files with code blocks — the seam test stub is just another code block in the consuming task's specification
- TASK-IC-6F94 (Child A) MUST be complete before this task begins
- TASK-IC-B4E6 (Child C) must not begin until this task is COMPLETED and verified

## Implementation Notes

- Files to modify: `installer/core/commands/feature-plan.md` (§3 task generation), `guardkit/orchestrator/quality_gates/coach_validator.py`
- **How consumer_context reaches the Coach:** The Coach receives task metadata (including consumer_context) via the orchestrator's `execute_coach()` call. Check `coach_validator.py`'s existing parameter signature to determine whether consumer_context should be added as a new parameter or extracted from the existing task metadata dict that's already passed in. Do not introduce a new data path if the existing one already carries task frontmatter.
- The Coach's adversarial intensity system already does full validation at complexity ≥5 — adding `consumer_context` reading gives the existing system what it needs without architectural changes
- See: `docs/reviews/autobuild-fixes/docker-fixtures-deep-analysis.md` §5.2 and §5.3 for the full design rationale
- See: `installer/core/commands/feature-plan.md` §4 (from TASK-IC-6F94) for the integration contract data that drives this task
