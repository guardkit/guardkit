---
id: TASK-FIX-GCI4
title: Implement feature spec seeding in /feature-plan
status: completed
task_type: implementation
created: 2026-02-08T23:00:00Z
updated: 2026-02-08T23:30:00Z
completed: 2026-02-08T23:30:00Z
priority: medium
parent_review: TASK-REV-C7EB
tags: [graphiti, feature-plan, seeding, knowledge-write]
complexity: 3
wave: 2
dependencies: [TASK-FIX-GCI0]
completed_location: tasks/completed/TASK-FIX-GCI4/
---

# Implement Feature Spec Seeding in /feature-plan

## CRITICAL: No Stubs Policy

**All code written for this task MUST be fully functional.** No placeholder methods, no `...` or `pass` in function bodies, no TODO comments deferring implementation. The `seed_feature_spec()` method must actually call `GraphitiClient.upsert_episode()` with a properly formatted episode body and correct metadata. Every function must do what its docstring says.

## Description

The feature-plan command spec (FEAT-GR-003) describes a bidirectional Graphiti integration: both **reading** context to enrich planning and **writing** the generated feature spec back to the knowledge graph. Currently, only the read path is implemented via `FeaturePlanContextBuilder.build_context()`. The write path (seeding) is missing.

This means feature specs created by `/feature-plan` are not stored in Graphiti, so subsequent queries for "related features" can only find manually seeded data - not specs generated by the system itself.

## What the Spec Says

From `installer/core/commands/feature-plan.md`, FEAT-GR-003:
- "Seed feature spec to knowledge graph"
- `[Graphiti] Seeded feature spec for FEAT-XXX`
- Group ID: `feature_specs` (project-scoped, will be prefixed as `{project_id}__feature_specs`)

## Graphiti API Reference (correct signatures)

### GraphitiClient.upsert_episode() - the method to use for seeding

Use `upsert_episode()` (not `add_episode()`) so re-running `/feature-plan` updates rather than duplicates:

```python
async def upsert_episode(
    self,
    name: str,                    # Episode display name
    episode_body: str,            # JSON string (from json.dumps())
    group_id: str,                # "feature_specs" (client auto-prefixes for project scope)
    entity_id: str,               # Stable ID, e.g., "FEAT-GR-006" (REQUIRED for upsert)
    source: str = "user_added",   # Use "feature_plan" for this integration
    entity_type: str = "generic", # Use "feature_spec"
    scope: Optional[str] = None,  # None = auto-detect (feature_specs is project-scoped)
    source_hash: Optional[str] = None,  # Auto-computed from episode_body if None
) -> Optional["UpsertResult"]
# Returns: UpsertResult(created=bool, updated=bool, skipped=bool, uuid=str)
# Returns: None on failure
```

### Episode body format (ADR-GBF-001: domain data only)

The `to_episode_body()` convention: return **domain data only**. The client injects `_metadata` automatically.

```python
# CORRECT: Domain data only
episode_body = json.dumps({
    "id": "FEAT-GR-006",
    "title": "Job-Specific Context Retrieval",
    "description": "Dynamic context budget allocation...",
    "tasks": ["TASK-GR6-001", "TASK-GR6-002", ...],
    "tech_stack": "python",
    "complexity": 7,
    "status": "planned",
})

# WRONG: Don't include metadata fields
episode_body = json.dumps({
    "id": "FEAT-GR-006",
    "entity_type": "feature_spec",     # NO - client adds this
    "_metadata": {...},                 # NO - client adds this
    "source": "feature_plan",          # NO - passed as parameter
    "created_at": "...",               # NO - client adds this
})
```

### Existing seeding pattern to follow (seed_feature_overviews.py)

```python
async def seed_feature_overview(client, overview: FeatureOverviewEntity) -> None:
    if client is None or not client.enabled:
        return

    try:
        episode_name = f"feature_overview_{overview.id}"
        episode_body = json.dumps(overview.to_episode_body())  # Domain data only

        await client.add_episode(
            name=episode_name,
            episode_body=episode_body,
            group_id="feature_overviews",
            source="guardkit_seeding",
            entity_type="feature_overview"
        )
        logger.info(f"Seeded feature overview: {overview.id}")
    except Exception as e:
        logger.warning(f"Failed to seed overview {overview.id}: {e}")
```

## Changes Required

### 1. Add seed_feature_spec() method to FeaturePlanContextBuilder

```python
async def seed_feature_spec(
    self,
    feature_id: str,
    feature_spec: Dict[str, Any],
    description: str,
) -> bool:
    """Seed generated feature spec to Graphiti knowledge graph.

    Uses upsert_episode() so re-running /feature-plan updates rather than
    duplicating the spec. The episode body follows ADR-GBF-001: domain data only.

    Args:
        feature_id: Feature identifier (e.g., "FEAT-GR-006")
        feature_spec: The generated feature specification dict
        description: Human-readable feature description

    Returns:
        True if seeded successfully, False otherwise (graceful degradation).
    """
    if self.graphiti_client is None or not self.graphiti_client.enabled:
        return False

    try:
        # Format episode body: domain data only (ADR-GBF-001)
        episode_body_dict = {
            "id": feature_id,
            "title": feature_spec.get("title", description),
            "description": description,
            "tasks": feature_spec.get("tasks", []),
            "tech_stack": feature_spec.get("tech_stack", "python"),
            "complexity": feature_spec.get("complexity"),
            "acceptance_criteria": feature_spec.get("acceptance_criteria", []),
            "architecture_notes": feature_spec.get("architecture_notes", ""),
            "status": "planned",
        }
        episode_body = json.dumps(episode_body_dict)

        result = await self.graphiti_client.upsert_episode(
            name=f"feature_spec_{feature_id}",
            episode_body=episode_body,
            group_id="feature_specs",       # Project-scoped, auto-prefixed
            entity_id=feature_id,           # Stable ID for upsert deduplication
            source="feature_plan",
            entity_type="feature_spec",
        )

        if result:
            action = "created" if result.created else ("updated" if result.updated else "skipped")
            logger.info(f"[Graphiti] Feature spec {feature_id}: {action}")
            return True
        return False

    except Exception as e:
        logger.warning(f"[Graphiti] Failed to seed feature spec {feature_id}: {e}")
        return False
```

### 2. Call seed_feature_spec() after feature plan generation

In the feature-plan execution flow, after the spec is generated:
```python
seeded = await builder.seed_feature_spec(
    feature_id=detected_feature_id,
    feature_spec=generated_spec,
    description=description,
)
# Logging is handled inside the method
```

### 3. Graceful degradation (mandatory 3-layer pattern)

```python
# Already built into seed_feature_spec():
if self.graphiti_client is None:       # Layer 1: Null check
    return False
if not self.graphiti_client.enabled:   # Layer 2: Enabled check
    return False
try:                                   # Layer 3: Try/except
    await self.graphiti_client.upsert_episode(...)
except Exception as e:
    logger.warning(f"...")
    return False                       # NEVER raise from Graphiti operations
```

## Acceptance Criteria

- [ ] `seed_feature_spec()` method added to `FeaturePlanContextBuilder`
- [ ] Feature spec is seeded to Graphiti using `upsert_episode()` (not `add_episode()`)
- [ ] Episode uses `feature_specs` group ID (project-scoped, auto-prefixed by client)
- [ ] Episode body contains ONLY domain data (ADR-GBF-001 compliant)
- [ ] `entity_id` is set to the feature_id for deduplication on re-runs
- [ ] `source` is `"feature_plan"`, `entity_type` is `"feature_spec"`
- [ ] Graceful degradation when Graphiti unavailable (returns False, no crash)
- [ ] Subsequent `build_context()` calls can find previously seeded specs via search
- [ ] Tests with mock Graphiti verify upsert_episode() is called with correct params
- [ ] Tests verify episode_body structure (domain data only, no metadata fields)
- [ ] Tests verify graceful degradation when client is None/disabled

## Files to Modify

- `guardkit/knowledge/feature_plan_context.py` - Add `seed_feature_spec()` method
- Feature-plan execution flow (identify exact calling location)
- New or updated tests

## Files for Reference (read before implementing)

- `guardkit/knowledge/seed_feature_overviews.py` - Working seeding pattern
- `guardkit/knowledge/graphiti_client.py` - `upsert_episode()` signature
- `guardkit/knowledge/outcome_manager.py` - Another capture/seeding example
- `docs/architecture/ADR-GBF-001-unified-episode-serialization.md` - Body format rules
- `docs/reviews/graphiti_baseline/graphiti-storage-theory.md` - Episode body conventions
- `installer/core/commands/feature-plan.md` - Spec describing seeding requirement
