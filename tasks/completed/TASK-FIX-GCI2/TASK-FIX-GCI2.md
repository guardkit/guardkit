---
id: TASK-FIX-GCI2
title: Implement run_abbreviated() for review knowledge capture
status: completed
task_type: implementation
created: 2026-02-08T23:00:00Z
updated: 2026-02-09T00:00:00Z
completed: 2026-02-09T00:00:00Z
priority: high
parent_review: TASK-REV-C7EB
tags: [graphiti, task-review, knowledge-capture, stub-fix]
complexity: 4
wave: 1
dependencies: []
completion:
  tests_passed: 61
  tests_added: 28
  files_modified: 1
  files_created: 1
  quality_gates: all_passed
---

# Implement run_abbreviated() for Review Knowledge Capture

## CRITICAL: No Stubs Policy

**All code written for this task MUST be fully functional.** No placeholder methods, no empty return values, no TODO comments deferring implementation. The current `run_abbreviated()` IS a stub - the entire point of this task is to replace it with working code. Every function must do what its docstring says. Every Graphiti call must use the correct API. Every episode must have proper metadata.

## Description

`InteractiveCaptureSession.run_abbreviated()` at `guardkit/knowledge/interactive_capture.py:432-471` is a **stub** that returns an empty result immediately without asking any questions or storing any knowledge to Graphiti. This makes the entire `/task-review --capture-knowledge` feature non-functional.

The full `run_session()` method (lines 110-430) in the same class is fully implemented with gap analysis, Q&A loops, and Graphiti storage. The abbreviated version should be a simplified flow that:
1. Iterates through provided questions (already generated by `ReviewKnowledgeCapture`)
2. Presents questions and collects answers via `ui_callback`
3. Processes answers into `CapturedKnowledge` items
4. Stores captured knowledge as episodes in Graphiti using `_save_captured_knowledge()`
5. Returns populated result dict

## Current Stub (to be REPLACED entirely)

```python
async def run_abbreviated(self, questions, task_context=None):
    task_context = task_context or {}
    captured_items: List[Dict[str, Any]] = []
    result: Dict[str, Any] = {
        "captured_items": captured_items,  # Always empty
        "task_id": task_context.get("task_id", ""),
        "review_mode": task_context.get("review_mode", ""),
    }
    return result  # Returns immediately, nothing captured
```

## How run_session() Works (the pattern to follow)

The existing `run_session()` at lines 110-430 shows the working pattern:

```python
async def run_session(self, focus=None, max_questions=10, ui_callback=None):
    # 1. Get gaps (SKIP this in abbreviated - questions are pre-generated)
    gaps = await self._get_gaps(focus, max_questions)

    # 2. Show intro via callback
    if ui_callback:
        ui_callback('intro', self._format_intro(gaps))

    # 3. For each question: show → get answer → process → capture
    for i, gap in enumerate(gaps):
        if ui_callback:
            ui_callback('question', {'number': i+1, 'total': len(gaps), ...})

        answer = ui_callback('get_input') if ui_callback else ''

        if answer.lower() in ('skip', 's', ''):
            continue
        if answer.lower() in ('quit', 'q', 'exit'):
            break

        captured = self._process_answer(gap, answer)  # → CapturedKnowledge
        self._captured.append(captured)

    # 4. Save ALL captured knowledge to Graphiti
    await self._save_captured_knowledge()

    # 5. Return results
    return list(self._captured)
```

### How _save_captured_knowledge() stores to Graphiti (lines 292-357)

This method groups captured items by category and stores each group as an episode:

```python
async def _save_captured_knowledge(self):
    """Save captured knowledge to Graphiti."""
    if not self._captured:
        return

    client = get_graphiti()
    if client is None or not client.enabled:
        return

    # Group by category
    by_category: Dict[KnowledgeCategory, List[CapturedKnowledge]] = {}
    for item in self._captured:
        by_category.setdefault(item.category, []).append(item)

    # Store each category as an episode
    for category, items in by_category.items():
        body_parts = [
            f"entity_type: captured_knowledge",
            f"category: {category.value}",
            f"source: interactive_capture",
            f"captured_at: {datetime.now(timezone.utc).isoformat()}",
            "",
            "QA Pairs:",
        ]
        for item in items:
            body_parts.append(f"Q: {item.question}")
            body_parts.append(f"A: {item.answer}")
            body_parts.append("")
        body_parts.append("Facts:")
        for item in items:
            for fact in item.facts:
                body_parts.append(f"- {fact}")

        episode_body = "\n".join(body_parts)

        try:
            await client.add_episode(
                name=f"captured_knowledge_{category.value}",
                episode_body=episode_body,
                group_id="captured_knowledge",
                source="interactive_capture",
                entity_type="captured_knowledge"
            )
        except Exception as e:
            logger.warning(f"Failed to store captured knowledge: {e}")
```

## Changes Required

### 1. Replace the stub with a full implementation

The new `run_abbreviated()` must:

```python
async def run_abbreviated(
    self,
    questions: List[str],
    task_context: Optional[Dict[str, Any]] = None,
    ui_callback: Optional[Callable] = None
) -> Dict[str, Any]:
    """Run abbreviated knowledge capture with pre-generated questions.

    Unlike run_session() which discovers gaps and generates questions,
    this method accepts pre-generated questions (from ReviewKnowledgeCapture)
    and runs the capture loop directly.
    """
    task_context = task_context or {}
    captured_items: List[Dict[str, Any]] = []
    review_mode = task_context.get("review_mode", "general")

    # Iterate through pre-generated questions
    for i, question in enumerate(questions):
        # Show question to user/agent
        if ui_callback:
            ui_callback('question', {
                'number': i + 1,
                'total': len(questions),
                'question': question,
                'review_mode': review_mode,
            })

        # Get answer
        answer = ""
        if ui_callback:
            answer = ui_callback('get_input')
        if not answer:
            continue

        # Skip/quit handling
        if answer.lower().strip() in ('skip', 's'):
            continue
        if answer.lower().strip() in ('quit', 'q', 'exit'):
            break

        # Process answer into CapturedKnowledge
        # Use _process_answer() pattern from run_session()
        captured = self._process_answer_from_text(question, answer, review_mode)
        self._captured.append(captured)

        captured_items.append({
            "question": question,
            "answer": answer,
            "category": captured.category.value,
            "facts": captured.facts,
        })

    # Save to Graphiti (uses existing _save_captured_knowledge)
    await self._save_captured_knowledge()

    result: Dict[str, Any] = {
        "captured_items": captured_items,
        "task_id": task_context.get("task_id", ""),
        "review_mode": review_mode,
        "questions_asked": len(questions),
        "answers_captured": len(captured_items),
    }
    return result
```

### 2. Add _process_answer_from_text() helper

Since `run_session()` uses gap objects but abbreviated uses plain question strings, add a helper that creates a `CapturedKnowledge` from a question/answer pair:

```python
def _process_answer_from_text(
    self, question: str, answer: str, review_mode: str
) -> CapturedKnowledge:
    """Process a text Q&A pair into CapturedKnowledge.

    Maps review mode to KnowledgeCategory and extracts facts from the answer.
    """
    # Map review mode to category
    mode_to_category = {
        "architectural": KnowledgeCategory.ARCHITECTURE,
        "code-quality": KnowledgeCategory.PATTERNS,
        "decision": KnowledgeCategory.DECISIONS,
        "technical-debt": KnowledgeCategory.PATTERNS,
        "security": KnowledgeCategory.CONSTRAINTS,
    }
    category = mode_to_category.get(review_mode, KnowledgeCategory.DOMAIN)

    # Extract facts from answer (sentence splitting)
    facts = self._extract_facts(answer)

    return CapturedKnowledge(
        question=question,
        answer=answer,
        category=category,
        facts=facts,
        confidence=0.8,
    )
```

### 3. Ensure _save_captured_knowledge() handles review context

The existing `_save_captured_knowledge()` stores to the `captured_knowledge` group. This works for abbreviated capture too. The episode body format includes the category and Q&A pairs, which is sufficient.

## Graphiti API Reference (correct signatures)

### GraphitiClient.add_episode() - used by _save_captured_knowledge()

```python
async def add_episode(
    self,
    name: str,               # Episode display name
    episode_body: str,        # Content (text or JSON string)
    group_id: str,            # Knowledge group (e.g., "captured_knowledge")
    scope: Optional[str] = None,
    metadata: Optional["EpisodeMetadata"] = None,
    source: str = "user_added",       # Origin identifier
    entity_type: str = "generic",     # Classification
) -> Optional[str]            # Returns UUID or None on failure
```

### Episode body format for captured knowledge

```python
# Text-based format (matches existing _save_captured_knowledge pattern):
episode_body = "\n".join([
    f"entity_type: captured_knowledge",
    f"category: {category.value}",
    f"source: interactive_capture",
    f"captured_at: {datetime.now(timezone.utc).isoformat()}",
    "",
    "QA Pairs:",
    f"Q: {question}",
    f"A: {answer}",
    "",
    "Facts:",
    f"- {fact1}",
    f"- {fact2}",
])
```

### Graceful degradation (mandatory 3-layer pattern)

```python
client = get_graphiti()
if client is None:                    # Layer 1: Null check
    return                            # Skip storage, don't crash
if not client.enabled:                # Layer 2: Enabled check
    return
try:                                  # Layer 3: Try/except
    await client.add_episode(...)
except Exception as e:
    logger.warning(f"Failed to store: {e}")
    # NEVER raise exceptions from Graphiti operations
```

## Acceptance Criteria

- [ ] `run_abbreviated()` iterates through ALL provided questions (3-5)
- [ ] Each question is presented via `ui_callback` (if provided)
- [ ] Answers are collected via `ui_callback('get_input')` (matching `run_session()` pattern)
- [ ] Skip/quit handling works (`skip`/`s` skips, `quit`/`q`/`exit` breaks)
- [ ] Each answer is processed into a `CapturedKnowledge` object with category and facts
- [ ] All captured knowledge is stored to Graphiti via `_save_captured_knowledge()`
- [ ] Episode body uses text format matching the existing pattern (entity_type, category, QA Pairs, Facts)
- [ ] Episodes are stored in `captured_knowledge` group with source `"interactive_capture"` and entity_type `"captured_knowledge"`
- [ ] Return value includes populated `captured_items` list with question, answer, category, facts
- [ ] Return value includes `questions_asked` and `answers_captured` counts
- [ ] Graceful degradation: capture works locally even when Graphiti unavailable (answers still in result dict)
- [ ] Existing tests updated to verify non-empty results when answers provided
- [ ] New tests verify: Q&A loop, skip handling, quit handling, Graphiti storage with mock, graceful degradation

## Files to Modify

- `guardkit/knowledge/interactive_capture.py` - Replace stub with full implementation
- `tests/test_task_review_knowledge_capture.py` - Update tests

## Files for Reference (read before implementing)

- `guardkit/knowledge/interactive_capture.py:110-430` - Full `run_session()` implementation (THE PATTERN)
- `guardkit/knowledge/interactive_capture.py:292-357` - `_save_captured_knowledge()` (THE STORAGE)
- `guardkit/knowledge/review_knowledge_capture.py` - Caller (`run_review_capture()`)
- `guardkit/knowledge/graphiti_client.py` - `add_episode()` signature

## Graphiti Documentation Reference

- `docs/reviews/graphiti_baseline/graphiti-storage-theory.md` - Episode body conventions
- `docs/architecture/ADR-GBF-001-unified-episode-serialization.md` - Serialization pattern
- `docs/deep-dives/graphiti/episode-metadata.md` - Metadata schema
