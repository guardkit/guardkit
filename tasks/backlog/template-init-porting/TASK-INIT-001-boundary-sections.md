---
id: TASK-INIT-001
title: "Port boundary sections to /template-init agent generation"
status: backlog
created: 2025-11-26T07:30:00Z
updated: 2025-11-26T07:30:00Z
priority: high
tags: [template-init, boundary-sections, week1, critical]
complexity: 6
estimated_hours: 8
parent_review: TASK-5E55
week: 1
phase: critical-features
related_tasks: []
test_results:
  status: pending
  coverage: null
  last_run: null
---

# Task: Port Boundary Sections to /template-init Agent Generation

## Problem Statement

`/template-init` generates agents without ALWAYS/NEVER/ASK boundary sections, missing Critical Gap #4 identified by GitHub's 2,500+ repo analysis. Agents lack explicit behavioral boundaries that prevent costly mistakes and reduce human intervention by 40%.

**Impact**: Users creating greenfield templates get agents without the boundary clarity that brownfield templates receive, creating an inferior and inconsistent experience.

## Analysis Findings

From TASK-5E55 review:
- `/template-create` includes boundary sections (TASK-STND-773D, 2025-11-22)
- GitHub analysis of 2,500+ repositories shows boundaries reduce human intervention by 40%
- `/template-init` generates basic agents but has NO boundary section generation logic
- The `greenfield_qa_session.py` (984 lines) has no boundary-related code
- Gap severity: üî¥ **CRITICAL**

**Current State**: Agents generated by `/template-init` lack explicit ALWAYS/NEVER/ASK sections that define behavioral boundaries.

**Desired State**: All agents generated by `/template-init` include validated boundary sections matching `/template-create` quality.

## Recommended Fix

**Approach**: Port the boundary section generation logic from `/template-create`'s agent enhancement to `/template-init`'s Phase 3 agent generation.

**Strategy**:
- **MINIMAL SCOPE**: Add only boundary generation functions, don't refactor existing code
- **REUSE**: Copy boundary logic from `agent-content-enhancer.md` patterns
- **VALIDATE**: Include validation function to ensure 5-7/5-7/3-5 rule counts
- **INTEGRATE**: Hook into existing Phase 3 without changing Q&A flow

## Code Changes Required

### File 1: installer/global/commands/lib/greenfield_qa_session.py

**BEFORE** (current - no boundary generation):
```python
# Line ~183: No boundary section generation exists
# Basic agent generation without boundaries
class TemplateInitQASession:
    # Agent generation doesn't include boundaries
```

**AFTER** (add boundary functions):

```python
# Add after line 183 (before class TemplateInitQASession)

def generate_boundary_sections(agent_type: str, technology: str) -> dict:
    """
    Generate ALWAYS/NEVER/ASK boundary sections for agent.

    Reused from template-create's agent enhancement logic (TASK-STND-773D).

    Args:
        agent_type: Type of agent (testing, repository, api, etc.)
        technology: Primary technology (python, typescript, csharp)

    Returns:
        dict with 'always', 'never', 'ask' lists

    Example:
        >>> boundaries = generate_boundary_sections('testing', 'python')
        >>> len(boundaries['always'])  # 5-7 rules
        5
    """
    boundaries = {
        "always": [],  # 5-7 rules
        "never": [],   # 5-7 rules
        "ask": []      # 3-5 scenarios
    }

    # Technology-specific boundaries (port from agent-content-enhancer.md)
    if agent_type == "testing":
        boundaries["always"] = [
            "‚úÖ Run build verification before tests (block if compilation fails)",
            "‚úÖ Execute in technology-specific test runner (pytest/vitest/dotnet test)",
            "‚úÖ Report failures with actionable error messages (aid debugging)",
            "‚úÖ Enforce 100% test pass rate (zero tolerance for failures)",
            "‚úÖ Validate test coverage thresholds (ensure quality gates met)"
        ]
        boundaries["never"] = [
            "‚ùå Never approve code with failing tests (zero tolerance policy)",
            "‚ùå Never skip compilation check (prevents false positive test runs)",
            "‚ùå Never modify test code to make tests pass (integrity violation)",
            "‚ùå Never ignore coverage below threshold (quality gate bypass prohibited)",
            "‚ùå Never run tests without dependency installation (environment consistency required)"
        ]
        boundaries["ask"] = [
            "‚ö†Ô∏è Coverage 70-79%: Ask if acceptable given task complexity and risk level",
            "‚ö†Ô∏è Performance tests failing: Ask if acceptable for non-production changes",
            "‚ö†Ô∏è Flaky tests detected: Ask if should quarantine or fix immediately"
        ]
    elif agent_type == "repository":
        boundaries["always"] = [
            "‚úÖ Inject repositories via constructor (enforces DI pattern)",
            "‚úÖ Return ErrorOr<T> for all operations (consistent error handling)",
            "‚úÖ Use async/await for database operations (prevents thread blocking)",
            "‚úÖ Implement IDisposable for database connections (resource cleanup)",
            "‚úÖ Validate input parameters before database access (prevent injection)"
        ]
        boundaries["never"] = [
            "‚ùå Never use `new()` for repository instantiation (breaks testability and DI)",
            "‚ùå Never expose IQueryable outside repository (violates encapsulation)",
            "‚ùå Never use raw SQL without parameterization (SQL injection risk)",
            "‚ùå Never ignore database errors (silent failures prohibited)",
            "‚ùå Never commit transactions within repository (violates SRP)"
        ]
        boundaries["ask"] = [
            "‚ö†Ô∏è Complex joins across >3 tables: Ask if raw SQL vs EF Core query",
            "‚ö†Ô∏è Caching strategy needed: Ask if in-memory vs distributed cache",
            "‚ö†Ô∏è Soft delete vs hard delete: Ask for data retention policy decision"
        ]
    elif agent_type == "api":
        boundaries["always"] = [
            "‚úÖ Validate all input parameters (prevent injection and bad data)",
            "‚úÖ Return consistent response format (successful and error responses)",
            "‚úÖ Use appropriate HTTP status codes (200/201/400/404/500)",
            "‚úÖ Implement request/response logging (audit trail and debugging)",
            "‚úÖ Apply rate limiting for endpoints (prevent abuse)"
        ]
        boundaries["never"] = [
            "‚ùå Never expose internal errors to clients (security risk)",
            "‚ùå Never skip authentication/authorization checks (security violation)",
            "‚ùå Never return sensitive data in responses (data leakage)",
            "‚ùå Never use GET for state-changing operations (violates REST)",
            "‚ùå Never ignore content-type headers (prevents incorrect parsing)"
        ]
        boundaries["ask"] = [
            "‚ö†Ô∏è Large payload (>10MB): Ask if streaming vs standard response",
            "‚ö†Ô∏è Long-running operation (>30s): Ask if async pattern needed",
            "‚ö†Ô∏è Multiple related endpoints: Ask if batch endpoint makes sense"
        ]
    else:
        # Generic boundaries for other agent types
        boundaries["always"] = [
            f"‚úÖ Follow {technology} best practices (maintain code quality)",
            "‚úÖ Validate all inputs (prevent bad data)",
            "‚úÖ Handle errors gracefully (never crash silently)",
            "‚úÖ Document public interfaces (enable team collaboration)",
            "‚úÖ Write unit tests for core logic (ensure correctness)"
        ]
        boundaries["never"] = [
            "‚ùå Never ignore exceptions (detect issues early)",
            "‚ùå Never hardcode configuration (use environment variables)",
            "‚ùå Never skip logging (maintain observability)",
            "‚ùå Never violate separation of concerns (maintain modularity)",
            "‚ùå Never commit secrets or credentials (security risk)"
        ]
        boundaries["ask"] = [
            "‚ö†Ô∏è Complex algorithm: Ask if optimization needed vs readability",
            "‚ö†Ô∏è External service call: Ask if retry logic needed",
            "‚ö†Ô∏è Performance concern: Ask if caching appropriate"
        ]

    return boundaries


def validate_boundary_sections(boundaries: dict) -> tuple[bool, list]:
    """
    Validate boundary sections meet requirements.

    Reused from template-create validation (TASK-STND-773D).

    Args:
        boundaries: Dict with 'always', 'never', 'ask' keys

    Returns:
        (is_valid, error_list)

    Validation rules:
    - ALWAYS: 5-7 rules with ‚úÖ prefix
    - NEVER: 5-7 rules with ‚ùå prefix
    - ASK: 3-5 scenarios with ‚ö†Ô∏è prefix
    """
    errors = []

    # Check counts
    always_count = len(boundaries.get("always", []))
    never_count = len(boundaries.get("never", []))
    ask_count = len(boundaries.get("ask", []))

    if always_count < 5 or always_count > 7:
        errors.append(f"ALWAYS section must have 5-7 rules (has {always_count})")
    if never_count < 5 or never_count > 7:
        errors.append(f"NEVER section must have 5-7 rules (has {never_count})")
    if ask_count < 3 or ask_count > 5:
        errors.append(f"ASK section must have 3-5 scenarios (has {ask_count})")

    # Check emoji format
    for rule in boundaries.get("always", []):
        if not rule.startswith("‚úÖ"):
            errors.append(f"ALWAYS rule missing ‚úÖ prefix: {rule[:50]}")
    for rule in boundaries.get("never", []):
        if not rule.startswith("‚ùå"):
            errors.append(f"NEVER rule missing ‚ùå prefix: {rule[:50]}")
    for scenario in boundaries.get("ask", []):
        if not scenario.startswith("‚ö†Ô∏è"):
            errors.append(f"ASK scenario missing ‚ö†Ô∏è prefix: {scenario[:50]}")

    return len(errors) == 0, errors
```

**Integration Point** (modify existing Phase 3 agent generation):
```python
# In TemplateInitQASession class, modify agent generation method
def _generate_agent(self, agent_type: str) -> str:
    """Generate agent with boundary sections."""
    technology = self._session_data.get('primary_language', 'unknown')

    # Generate boundary sections
    boundaries = generate_boundary_sections(agent_type, technology)

    # Validate boundaries
    is_valid, errors = validate_boundary_sections(boundaries)
    if not is_valid:
        print(f"‚ö†Ô∏è Boundary validation warnings for {agent_type}:")
        for error in errors:
            print(f"   - {error}")

    # Format boundaries into markdown
    boundary_section = "\n## Boundaries\n\n"
    boundary_section += "### ALWAYS\n"
    for rule in boundaries["always"]:
        boundary_section += f"- {rule}\n"
    boundary_section += "\n### NEVER\n"
    for rule in boundaries["never"]:
        boundary_section += f"- {rule}\n"
    boundary_section += "\n### ASK\n"
    for scenario in boundaries["ask"]:
        boundary_section += f"- {scenario}\n"

    # Insert boundaries after Quick Start section in agent
    agent_content = self._generate_base_agent_content(agent_type)
    # Insert boundary_section after "## Quick Start" heading

    return agent_content
```

## Scope Constraints

### ‚ùå DO NOT
- Modify the Q&A workflow (Phases 1-2) - they work fine
- Change agent file format beyond adding boundaries section
- Refactor existing agent generation logic - too risky
- Add new dependencies or libraries
- Make boundaries mandatory if agent type unknown
- Block template generation on boundary validation failures

### ‚úÖ DO ONLY
- Add `generate_boundary_sections()` function (technology-specific)
- Add `validate_boundary_sections()` function (5-7/5-7/3-5 checks)
- Integrate boundaries into Phase 3 agent generation
- Display validation warnings (don't block on errors)
- Maintain backward compatibility with existing code
- Use emoji prefixes: ‚úÖ ALWAYS, ‚ùå NEVER, ‚ö†Ô∏è ASK

## Files to Modify

1. **installer/global/commands/lib/greenfield_qa_session.py** - ADD
   - `generate_boundary_sections()` function (~80 lines)
   - `validate_boundary_sections()` function (~30 lines)

2. **installer/global/commands/lib/greenfield_qa_session.py** - MODIFY
   - `_generate_agent()` method to include boundaries (~15 lines changed)
   - Phase 3 agent generation to validate boundaries

## Files to NOT Touch

- `installer/global/commands/template-init.md` - No spec changes needed yet (will update in TASK-INIT-010)
- Any other Q&A session files - Keep focused on agent generation only
- `agent-content-enhancer.md` - Source of truth, don't modify
- Existing Q&A phases (1-2, 4) - Working correctly

## Testing Requirements

### Unit Tests
```python
def test_generate_boundary_sections_testing_agent():
    """Test boundary generation for testing agent."""
    boundaries = generate_boundary_sections('testing', 'python')

    assert 5 <= len(boundaries['always']) <= 7
    assert 5 <= len(boundaries['never']) <= 7
    assert 3 <= len(boundaries['ask']) <= 5

    # Check emoji prefixes
    for rule in boundaries['always']:
        assert rule.startswith('‚úÖ')
    for rule in boundaries['never']:
        assert rule.startswith('‚ùå')
    for scenario in boundaries['ask']:
        assert scenario.startswith('‚ö†Ô∏è')

def test_validate_boundary_sections_valid():
    """Test validation with valid boundaries."""
    boundaries = {
        'always': ['‚úÖ Rule ' + str(i) for i in range(5)],
        'never': ['‚ùå Rule ' + str(i) for i in range(5)],
        'ask': ['‚ö†Ô∏è Scenario ' + str(i) for i in range(3)]
    }

    is_valid, errors = validate_boundary_sections(boundaries)
    assert is_valid
    assert len(errors) == 0

def test_validate_boundary_sections_invalid_count():
    """Test validation catches count violations."""
    boundaries = {
        'always': ['‚úÖ Rule 1', '‚úÖ Rule 2'],  # Too few (need 5-7)
        'never': ['‚ùå Rule'] * 10,  # Too many (need 5-7)
        'ask': []  # Too few (need 3-5)
    }

    is_valid, errors = validate_boundary_sections(boundaries)
    assert not is_valid
    assert len(errors) >= 3
```

### Integration Tests
```python
def test_generated_agents_include_boundaries():
    """Test that generated agents include valid boundaries."""
    session = TemplateInitQASession()
    session._session_data = {
        'primary_language': 'python',
        'framework': 'fastapi'
    }

    agent_content = session._generate_agent('testing')

    assert '## Boundaries' in agent_content
    assert '### ALWAYS' in agent_content
    assert '### NEVER' in agent_content
    assert '### ASK' in agent_content
    assert '‚úÖ' in agent_content
    assert '‚ùå' in agent_content
    assert '‚ö†Ô∏è' in agent_content
```

### Regression Tests
```python
def test_existing_qa_workflow_unchanged():
    """Ensure Q&A workflow still works."""
    session = TemplateInitQASession()

    # Mock Q&A responses
    with patch('inquirer.prompt') as mock_prompt:
        mock_prompt.return_value = {
            'template_name': 'test',
            'template_purpose': 'quick_start'
        }
        session._section1_identity()

    assert session._session_data['template_name'] == 'test'
```

## Acceptance Criteria

- [ ] `generate_boundary_sections()` function implemented with 4+ agent types
- [ ] `validate_boundary_sections()` function checks 5-7/5-7/3-5 counts
- [ ] All generated agents include ALWAYS/NEVER/ASK sections
- [ ] Boundaries pass validation (correct counts and emoji prefixes)
- [ ] Emoji prefixes correct: ‚úÖ ALWAYS, ‚ùå NEVER, ‚ö†Ô∏è ASK
- [ ] Validation warnings displayed but don't block creation
- [ ] Technology-specific boundaries for Python, TypeScript, C#
- [ ] Generic boundaries for unknown agent types
- [ ] No regressions in existing Q&A workflow (Phases 1-2, 4)
- [ ] Unit tests achieve 90%+ coverage for new functions
- [ ] Integration tests verify boundaries in generated agents

## Estimated Effort

**8 hours** broken down as:
- Research existing boundary patterns (1 hour)
- Implement `generate_boundary_sections()` (3 hours)
- Implement `validate_boundary_sections()` (1 hour)
- Integrate with Phase 3 agent generation (2 hours)
- Testing and validation (1 hour)

## Dependencies

**None** - This is the first task (Week 1, Critical Features)

## Risk Assessment

### Risks

| Risk | Probability | Impact | Severity |
|------|------------|--------|----------|
| Boundary generation might not fit all agent types | Medium | Low | üü° Low |
| Validation too strict for greenfield templates | Low | Low | üü¢ Minimal |
| Integration breaks existing agent generation | Low | Medium | üü° Low |
| Emoji rendering issues in some terminals | Low | Low | üü¢ Minimal |

### Mitigation Strategies

1. **Agent type coverage**: Start with 4 core types (testing, repository, api, generic), expand later
2. **Validation strictness**: Use warnings instead of errors, allow template creation to proceed
3. **Integration safety**: Add boundaries after existing generation completes, minimal changes
4. **Emoji compatibility**: Use standard Unicode emojis supported in modern terminals

### Rollback Plan

If issues arise:
1. Comment out boundary generation calls in Phase 3
2. Agents will generate without boundaries (existing behavior)
3. No data loss or breaking changes
4. Can re-enable after fixes

## References

- **Parent Review**: [TASK-5E55](tasks/in_review/TASK-5E55-review-greenfield-initialization-workflow.md)
- **Decision Analysis**: [docs/decisions/template-init-vs-template-create-analysis.md](docs/decisions/template-init-vs-template-create-analysis.md)
- **Source Feature**: TASK-STND-773D (boundary sections in /template-create)
- **GitHub Analysis**: [docs/analysis/github-agent-best-practices-analysis.md](docs/analysis/github-agent-best-practices-analysis.md)
- **Agent Enhancer**: [installer/global/agents/agent-content-enhancer.md](installer/global/agents/agent-content-enhancer.md)

## Success Metrics

When complete:
- ‚úÖ 100% of generated agents include boundary sections
- ‚úÖ 100% of boundaries pass validation (5-7/5-7/3-5 format)
- ‚úÖ 0 regressions in existing Q&A workflow
- ‚úÖ 4+ agent types have technology-specific boundaries
- ‚úÖ Validation displays helpful warnings for users
