"""Custom exceptions for orchestrator components."""

from dataclasses import dataclass
from typing import Any, Dict, Optional


# ============================================================================
# Data Classes for Agent Invocation Results
# ============================================================================


@dataclass
class TaskWorkResult:
    """Result of task-work command execution.

    Attributes:
        success: True if task-work completed successfully
        output: Parsed output from task-work (test results, coverage, etc.)
        error: Error message if task-work failed
        exit_code: Process exit code
    """

    success: bool
    output: Dict[str, Any]
    error: Optional[str] = None
    exit_code: int = 0


# ============================================================================
# Blocked Report Data Classes (Escape Hatch Pattern)
# ============================================================================


from enum import Enum
from typing import List


class BlockingCategory(Enum):
    """Categories of blocking issues for structured reporting.

    Known categories help with automated analysis and routing.
    Use 'other' for issues that don't fit standard categories.
    """

    test_failure = "test_failure"
    dependency_issue = "dependency_issue"
    architectural_violation = "architectural_violation"
    requirements_unclear = "requirements_unclear"
    external_blocker = "external_blocker"
    timeout_exceeded = "timeout_exceeded"
    resource_unavailable = "resource_unavailable"
    other = "other"

    @classmethod
    def from_string(cls, value: str) -> "BlockingCategory":
        """Convert string to BlockingCategory, defaulting to 'other' if unknown."""
        try:
            return cls(value)
        except ValueError:
            return cls.other


@dataclass
class BlockingIssue:
    """A single blocking issue preventing task completion.

    Attributes:
        category: Type of blocking issue (from BlockingCategory)
        description: Human-readable description of the issue
        file_path: Optional file path where issue occurs
        line_number: Optional line number where issue occurs
        attempted_fixes: List of fixes that were attempted
        root_cause: Analysis of the underlying cause
    """

    category: BlockingCategory
    description: str
    file_path: Optional[str] = None
    line_number: Optional[int] = None
    attempted_fixes: Optional[List[str]] = None
    root_cause: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            "category": self.category.value,
            "description": self.description,
            "file_path": self.file_path,
            "line_number": self.line_number,
            "attempted_fixes": self.attempted_fixes or [],
            "root_cause": self.root_cause,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "BlockingIssue":
        """Create from dictionary."""
        return cls(
            category=BlockingCategory.from_string(data.get("category", "other")),
            description=data.get("description", ""),
            file_path=data.get("file_path"),
            line_number=data.get("line_number"),
            attempted_fixes=data.get("attempted_fixes"),
            root_cause=data.get("root_cause"),
        )


@dataclass
class AttemptRecord:
    """Record of an implementation attempt.

    Attributes:
        turn: Turn number when attempt was made
        approach: Description of the approach taken
        outcome: What happened (success/failure/partial)
        learnings: What was learned from this attempt
    """

    turn: int
    approach: str
    outcome: str
    learnings: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            "turn": self.turn,
            "approach": self.approach,
            "outcome": self.outcome,
            "learnings": self.learnings,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "AttemptRecord":
        """Create from dictionary."""
        return cls(
            turn=data.get("turn", 0),
            approach=data.get("approach", ""),
            outcome=data.get("outcome", ""),
            learnings=data.get("learnings"),
        )


@dataclass
class BlockedReport:
    """Structured report when task cannot be completed autonomously.

    Generated by Player agent when approaching max turns without approval.
    Provides human reviewer with actionable information.

    Attributes:
        blocking_issues: List of issues preventing completion
        attempts_made: Record of implementation attempts
        suggested_alternatives: Possible paths forward
        human_action_required: Specific actions needed from human
    """

    blocking_issues: List[BlockingIssue]
    attempts_made: List[AttemptRecord]
    suggested_alternatives: List[str]
    human_action_required: str

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            "blocking_issues": [issue.to_dict() for issue in self.blocking_issues],
            "attempts_made": [attempt.to_dict() for attempt in self.attempts_made],
            "suggested_alternatives": self.suggested_alternatives,
            "human_action_required": self.human_action_required,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "BlockedReport":
        """Create from dictionary."""
        return cls(
            blocking_issues=[
                BlockingIssue.from_dict(issue)
                for issue in data.get("blocking_issues", [])
            ],
            attempts_made=[
                AttemptRecord.from_dict(attempt)
                for attempt in data.get("attempts_made", [])
            ],
            suggested_alternatives=data.get("suggested_alternatives", []),
            human_action_required=data.get("human_action_required", ""),
        )

    @classmethod
    def from_player_report(cls, report: Dict[str, Any]) -> Optional["BlockedReport"]:
        """Extract BlockedReport from Player report if present.

        Args:
            report: Player report dictionary

        Returns:
            BlockedReport if present in report, None otherwise
        """
        blocked_report_data = report.get("blocked_report")
        if blocked_report_data:
            return cls.from_dict(blocked_report_data)
        return None


# ============================================================================
# AgentInvoker Exceptions
# ============================================================================


class AgentInvokerError(Exception):
    """Base exception for AgentInvoker errors."""

    pass


class AgentInvocationError(AgentInvokerError):
    """Raised when SDK invocation fails."""

    pass


class PlayerReportNotFoundError(AgentInvokerError):
    """Raised when Player doesn't create report."""

    pass


class PlayerReportInvalidError(AgentInvokerError):
    """Raised when Player report JSON is malformed."""

    pass


class CoachDecisionNotFoundError(AgentInvokerError):
    """Raised when Coach doesn't create decision."""

    pass


class CoachDecisionInvalidError(AgentInvokerError):
    """Raised when Coach decision JSON is malformed."""

    pass


class SDKTimeoutError(AgentInvokerError):
    """Raised when SDK invocation times out."""

    pass


class RateLimitExceededError(AgentInvokerError):
    """Raised when API rate limit is exceeded.

    Attributes:
        reset_time: Optional estimated reset time from error message
    """

    def __init__(self, message: str, reset_time: Optional[str] = None):
        super().__init__(message)
        self.reset_time = reset_time


# ============================================================================
# Orchestration Exceptions
# ============================================================================


class OrchestrationError(Exception):
    """Base exception for orchestration errors."""

    pass


class SetupPhaseError(OrchestrationError):
    """Raised when setup phase fails."""

    pass


class LoopPhaseError(OrchestrationError):
    """Raised when loop phase encounters critical error."""

    pass


class FinalizePhaseError(OrchestrationError):
    """Raised when finalize phase fails."""

    pass


# ============================================================================
# Task State Exceptions
# ============================================================================


class TaskStateError(OrchestrationError):
    """Base exception for task state errors.

    Raised when task state transition fails or state validation fails.

    Attributes:
        task_id: Task identifier
        current_state: Current state of the task
        expected_state: Expected state of the task
    """

    def __init__(
        self,
        message: str,
        task_id: Optional[str] = None,
        current_state: Optional[str] = None,
        expected_state: Optional[str] = None,
    ):
        self.task_id = task_id
        self.current_state = current_state
        self.expected_state = expected_state
        super().__init__(message)


class PlanNotFoundError(TaskStateError):
    """Raised when implementation plan is missing or invalid.

    Attributes:
        plan_path: Expected path to the implementation plan
    """

    def __init__(self, message: str, plan_path: Optional[str] = None, **kwargs):
        self.plan_path = plan_path
        super().__init__(message, **kwargs)


class StateValidationError(TaskStateError):
    """Raised when state validation fails.

    Used when the task state doesn't match expected requirements
    for a given operation (e.g., implement-only requires design_approved).
    """

    pass
