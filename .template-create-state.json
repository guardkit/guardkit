{
  "version": "1.0",
  "checkpoint": "templates_generated",
  "phase": 4,
  "created_at": "2025-11-18T11:32:25.071516+00:00",
  "updated_at": "2025-11-18T11:32:25.071664+00:00",
  "config": {
    "codebase_path": "/Users/richardwoollcott/Projects/Appmilla/Ai/my_drive/test_templates/DeCUK.Mobile.MyDrive",
    "output_path": null,
    "output_location": "global",
    "max_templates": null,
    "dry_run": false,
    "save_analysis": false,
    "no_agents": false,
    "verbose": true,
    "skip_validation": false,
    "auto_fix_templates": true,
    "interactive_validation": true,
    "validate": false,
    "resume": false,
    "custom_name": "debug-test"
  },
  "phase_data": {
    "qa_answers": null,
    "analysis": {
      "codebase_path": "/Users/richardwoollcott/Projects/Appmilla/Ai/my_drive/test_templates/DeCUK.Mobile.MyDrive",
      "analyzed_at": "2025-11-18T11:32:24.882555",
      "technology": {
        "primary_language": "C#",
        "frameworks": [
          ".NET",
          ".NET MAUI"
        ],
        "testing_frameworks": [
          "xUnit / NUnit"
        ],
        "build_tools": [],
        "databases": [],
        "infrastructure": [
          "Docker Compose"
        ],
        "confidence": {
          "level": "medium",
          "percentage": 75.0,
          "reasoning": "Heuristic detection based on file patterns"
        }
      },
      "architecture": {
        "patterns": [
          "Repository",
          "Factory",
          "Service Layer"
        ],
        "architectural_style": "Standard Structure",
        "layers": [],
        "key_abstractions": [],
        "dependency_flow": "Inward toward domain (assumed)",
        "confidence": {
          "level": "medium",
          "percentage": 70.0,
          "reasoning": "Heuristic detection without deep semantic analysis"
        }
      },
      "quality": {
        "overall_score": 70.0,
        "solid_compliance": 70.0,
        "dry_compliance": 70.0,
        "yagni_compliance": 70.0,
        "test_coverage": null,
        "code_smells": [],
        "strengths": [
          "Standard project structure"
        ],
        "improvements": [
          "Run full architectural review for detailed insights"
        ],
        "confidence": {
          "level": "low",
          "percentage": 60.0,
          "reasoning": "Quality metrics require deep analysis - use agent for accurate results"
        }
      },
      "example_files": [
        {
          "path": "DeCUK.Mobile.MyDrive/Data/RealmQuery.cs",
          "purpose": "Source file (RealmQuery)",
          "layer": "Infrastructure",
          "patterns_used": [],
          "key_concepts": []
        },
        {
          "path": "DeCUK.Mobile.MyDrive/Engines/Interfaces/ILoadingValidator.cs",
          "purpose": "Source file (ILoadingValidator)",
          "layer": null,
          "patterns_used": [],
          "key_concepts": []
        },
        {
          "path": "DeCUK.Mobile.MyDrive/Entities/ParcelValidationResult.cs",
          "purpose": "Source file (ParcelValidationResult)",
          "layer": "Domain",
          "patterns_used": [],
          "key_concepts": []
        },
        {
          "path": "DeCUK.Mobile.MyDrive/Services/ConfigurationService.cs",
          "purpose": "Source file (ConfigurationService)",
          "layer": "Application",
          "patterns_used": [],
          "key_concepts": []
        },
        {
          "path": "DeCUK.Mobile.MyDrive/Engines/ConfigurationEngine.cs",
          "purpose": "Source file (ConfigurationEngine)",
          "layer": null,
          "patterns_used": [],
          "key_concepts": []
        },
        {
          "path": "DeCUK.Mobile.MyDrive/Services/Interfaces/IConfigurationService.cs",
          "purpose": "Source file (IConfigurationService)",
          "layer": "Application",
          "patterns_used": [],
          "key_concepts": []
        },
        {
          "path": "DeCUK.Mobile.MyDrive/Payloads/ConfigurationPayload.cs",
          "purpose": "Source file (ConfigurationPayload)",
          "layer": null,
          "patterns_used": [],
          "key_concepts": []
        },
        {
          "path": "DeCUK.Mobile.MyDrive/Core/Models/AppErrors.cs",
          "purpose": "Source file (AppErrors)",
          "layer": "Domain",
          "patterns_used": [],
          "key_concepts": []
        },
        {
          "path": "DeCUK.Mobile.MyDrive/Controls/DomainCameraView.cs",
          "purpose": "Source file (DomainCameraView)",
          "layer": "Domain",
          "patterns_used": [],
          "key_concepts": []
        },
        {
          "path": "DeCUK.Mobile.MyDrive/AsyncDataServices/ScanAsyncDataService.cs",
          "purpose": "Source file (ScanAsyncDataService)",
          "layer": "Application",
          "patterns_used": [],
          "key_concepts": []
        },
        {
          "path": "DeCUK.Mobile.MyDrive/Repositories/ConfigurationRepository.cs",
          "purpose": "Source file (ConfigurationRepository)",
          "layer": "Infrastructure",
          "patterns_used": [],
          "key_concepts": []
        },
        {
          "path": "DeCUK.Mobile.MyDrive/Repositories/LoadingRepository.cs",
          "purpose": "Source file (LoadingRepository)",
          "layer": "Infrastructure",
          "patterns_used": [],
          "key_concepts": []
        },
        {
          "path": "DeCUK.Mobile.MyDrive/Services/LoadingSummaryService.cs",
          "purpose": "Source file (LoadingSummaryService)",
          "layer": "Application",
          "patterns_used": [],
          "key_concepts": []
        },
        {
          "path": "DeCUK.Mobile.MyDrive/Repositories/DriverRepository.cs",
          "purpose": "Source file (DriverRepository)",
          "layer": "Infrastructure",
          "patterns_used": [],
          "key_concepts": []
        },
        {
          "path": "DeCUK.Mobile.MyDrive/Services/DeCUKBaseApiClientService.cs",
          "purpose": "Source file (DeCUKBaseApiClientService)",
          "layer": "Application",
          "patterns_used": [],
          "key_concepts": []
        }
      ],
      "template_context": null,
      "agent_used": false,
      "fallback_reason": "Agent not available - using heuristic analysis",
      "analysis_version": "0.1.0"
    },
    "manifest": {
      "schema_version": "1.0.0",
      "name": "debug-test",
      "display_name": "C# Standard Structure",
      "description": "C# template using Standard Structure architecture with .NET, .NET MAUI",
      "version": "1.0.0",
      "author": "Richard Woollcott",
      "language": "C#",
      "language_version": "net9.0",
      "frameworks": [
        {
          "name": ".NET",
          "version": "17.14.1",
          "purpose": "core"
        },
        {
          "name": ".NET MAUI",
          "version": null,
          "purpose": "ui"
        },
        {
          "name": "xUnit / NUnit",
          "version": null,
          "purpose": "testing"
        }
      ],
      "architecture": "Standard Structure",
      "patterns": [
        "Factory",
        "Repository",
        "Service Layer"
      ],
      "layers": [],
      "placeholders": {
        "ProjectName": {
          "name": "{{ProjectName}}",
          "description": "Name of the project/solution",
          "default_value": null,
          "pattern": "^[A-Za-z][A-Za-z0-9_]*$",
          "required": true
        },
        "Namespace": {
          "name": "{{Namespace}}",
          "description": "Root namespace for the project",
          "default_value": null,
          "pattern": "^[A-Za-z][A-Za-z0-9_]*(\\.[A-Za-z][A-Za-z0-9_]*)*$",
          "required": true
        },
        "Author": {
          "name": "{{Author}}",
          "description": "Project author name",
          "default_value": "Richard Woollcott",
          "pattern": null,
          "required": false
        }
      },
      "tags": [
        ".net",
        ".net-maui",
        "c#",
        "factory",
        "repository",
        "service-layer",
        "standard-structure",
        "xunit-/-nunit"
      ],
      "category": "mobile",
      "complexity": 7,
      "compatible_with": [],
      "requires": [
        "agent:dotnet-domain-specialist"
      ],
      "created_at": "2025-11-18T11:32:25.068332",
      "source_project": "/Users/richardwoollcott/Projects/Appmilla/Ai/my_drive/test_templates/DeCUK.Mobile.MyDrive",
      "confidence_score": 68.33
    },
    "settings": {
      "schema_version": "1.0.0",
      "naming_conventions": {
        "class": {
          "element_type": "class",
          "pattern": "{{Name}}",
          "case_style": "PascalCase",
          "prefix": null,
          "suffix": ".cs",
          "examples": [
            "RealmQuery",
            "ILoadingValidator",
            "ParcelValidationResult",
            "ConfigurationService",
            "ConfigurationEngine"
          ]
        },
        "interface": {
          "element_type": "interface",
          "pattern": "I{{Name}}",
          "case_style": "PascalCase",
          "prefix": "I",
          "suffix": ".cs",
          "examples": [
            "RealmQuery",
            "ILoadingValidator"
          ]
        },
        "method": {
          "element_type": "method",
          "pattern": "{{Name}}",
          "case_style": "PascalCase",
          "prefix": null,
          "suffix": null,
          "examples": [
            "RealmQuery",
            "ILoadingValidator"
          ]
        },
        "property": {
          "element_type": "property",
          "pattern": "{{Name}}",
          "case_style": "PascalCase",
          "prefix": null,
          "suffix": null,
          "examples": [
            "RealmQuery",
            "ILoadingValidator"
          ]
        },
        "field": {
          "element_type": "field",
          "pattern": "_{{name}}",
          "case_style": "camelCase",
          "prefix": "_",
          "suffix": null,
          "examples": []
        }
      },
      "file_organization": {
        "by_layer": false,
        "by_feature": false,
        "test_location": "separate",
        "max_files_per_directory": 50
      },
      "layer_mappings": {},
      "code_style": {
        "indentation": "spaces",
        "indent_size": 4,
        "line_length": 120,
        "trailing_commas": false
      },
      "generation_options": {
        "preserve_comments": true,
        "preserve_whitespace": true,
        "auto_format": true
      }
    },
    "templates": {
      "total_count": 15,
      "templates": [
        {
          "schema_version": "1.0.0",
          "name": "RealmQuery.cs.template",
          "original_path": "DeCUK.Mobile.MyDrive/Data/RealmQuery.cs",
          "template_path": "templates/other/RealmQuery.cs.template",
          "content": "\ufeffusing Realms;\n\nnamespace {{ProjectName}}\n{\n    public class RealmQuery : RealmObject\n    {\n        public int QueryType { get; set; }\n        public string QueryIdentifier { get; set; }\n        public int IdentifierType { get; set; }\n        public bool Authorised { get; set; }\n        public int GroupId { get; set; }\n        public string AuthorisedBy { get; set; }\n        public DateTimeOffset AuthorisedDateTime { get; set; }\n    }\n}\n",
          "placeholders": [
            "ProjectName"
          ],
          "file_type": null,
          "language": "C#",
          "purpose": "Source file (RealmQuery)",
          "quality_score": null,
          "patterns": [],
          "created_at": "2025-11-18T11:32:25.069150"
        },
        {
          "schema_version": "1.0.0",
          "name": "ILoadingValidator.cs.template",
          "original_path": "DeCUK.Mobile.MyDrive/Engines/Interfaces/ILoadingValidator.cs",
          "template_path": "templates/other/ILoadingValidator.cs.template",
          "content": "using ErrorOr;\nusing DeCUK.Mobile.MyDrive.Entities;\n\nnamespace {{ProjectName}};\n\n/// <summary>\n/// Validates parcels and loading completion.\n/// Used by completion screens and validation flows.\n/// </summary>\n/// <remarks>\n/// This is a focused interface following the Interface Segregation Principle (ISP).\n/// Clients that need to validate parcels or check loading completion can depend on\n/// this interface without being forced to depend on processing, reporting, or lifecycle operations.\n/// </remarks>\n/// <example>\n/// <code>\n/// public class LoadCompletionViewModel\n/// {\n///     private readonly ILoadingValidator _validator;\n///\n///     public async Task CheckCompletion()\n///     {\n///         var result = await _validator.IsLoadingCompleteAsync(_loadingContext);\n///\n///         result.Match(\n///             Right: isComplete => UpdateCompletionStatus(isComplete),\n///             Left: error => HandleError(error));\n///     }\n/// }\n/// </code>\n/// </example>\npublic interface ILoadingValidator\n{\n    /// <summary>\n    /// Validates if a parcel is eligible for loading.\n    /// </summary>\n    /// <param name=\"barcode\">The parcel barcode/consignment number to validate</param>\n    /// <param name=\"context\">Loading context for validation rules</param>\n    /// <returns>\n    /// ErrorOr containing:\n    /// - Right: ParcelValidationResult with validation outcome and details\n    /// - Left: Error indicating why the validation could not be performed\n    /// </returns>\n    /// <remarks>\n    /// Validation checks include:\n    /// - Parcel exists in the system\n    /// - Parcel is assigned to the correct route\n    /// - Parcel has not already been scanned\n    /// - High-value parcel handling (if applicable)\n    /// - Stop sequence validation\n    /// </remarks>\n    Task<ErrorOr<ParcelValidationResult>> ValidateParcelAsync(\n        string barcode,\n        LoadingContext context);\n\n    /// <summary>\n    /// Checks if loading is complete for a route.\n    /// </summary>\n    /// <param name=\"context\">The current loading context containing route and driver information</param>\n    /// <returns>\n    /// ErrorOr containing:\n    /// - Right: True if all parcels have been scanned, false otherwise\n    /// - Left: Error indicating why the completion check could not be performed\n    /// </returns>\n    /// <remarks>\n    /// Loading is considered complete when:\n    /// - All expected parcels have been scanned\n    /// - No pending parcels remain\n    /// - All high-value parcels have been accounted for (if applicable)\n    /// </remarks>\n    Task<ErrorOr<bool>> IsLoadingCompleteAsync(LoadingContext context);\n\n    /// <summary>\n    /// Validates that loading is complete and ready to finalize.\n    /// </summary>\n    /// <param name=\"routeId\">The route identifier to validate</param>\n    /// <param name=\"driverId\">The driver identifier for authorization check</param>\n    /// <returns>\n    /// ErrorOr containing:\n    /// - Right: True if valid to complete loading, false otherwise\n    /// - Left: Error indicating why the validation failed\n    /// </returns>\n    /// <remarks>\n    /// This performs comprehensive validation including:\n    /// - All parcels scanned\n    /// - Driver is authorized for the route\n    /// - No outstanding issues or exceptions\n    /// - Loading session is still active\n    /// This should be called before finalizing/closing a loading session.\n    /// </remarks>\n    Task<ErrorOr<bool>> ValidateLoadingCompleteAsync(string routeId, string driverId);\n}\n",
          "placeholders": [
            "ProjectName"
          ],
          "file_type": null,
          "language": "C#",
          "purpose": "Source file (ILoadingValidator)",
          "quality_score": null,
          "patterns": [
            "Result type pattern",
            "Async/await",
            "Interface-based abstraction",
            "MVVM"
          ],
          "created_at": "2025-11-18T11:32:25.069324"
        },
        {
          "schema_version": "1.0.0",
          "name": "ParcelValidationResult.cs.template",
          "original_path": "DeCUK.Mobile.MyDrive/Entities/ParcelValidationResult.cs",
          "template_path": "templates/other/ParcelValidationResult.cs.template",
          "content": "namespace {{ProjectName}};\n\n/// <summary>\n/// Result of parcel validation operation.\n/// Indicates whether a parcel is valid for loading and provides details.\n/// </summary>\n/// <remarks>\n/// Returned by ILoadingValidator.ValidateParcelAsync.\n/// Provides comprehensive information about why a parcel is or isn't valid.\n/// </remarks>\npublic class ParcelValidationResult\n{\n    /// <summary>\n    /// Whether the parcel is valid for loading.\n    /// </summary>\n    public bool IsValid { get; set; }\n\n    /// <summary>\n    /// The parcel identifier (barcode/consignment number).\n    /// </summary>\n    public string ParcelId { get; set; } = string.Empty;\n\n    /// <summary>\n    /// Message describing the validation result.\n    /// </summary>\n    public string Message { get; set; } = string.Empty;\n\n    /// <summary>\n    /// Whether this is a high-value parcel.\n    /// </summary>\n    public bool IsHighValue { get; set; }\n\n    /// <summary>\n    /// Whether the parcel has already been scanned.\n    /// </summary>\n    public bool AlreadyScanned { get; set; }\n\n    /// <summary>\n    /// Whether the parcel is in the expected route list.\n    /// </summary>\n    public bool InExpectedList { get; set; }\n\n    /// <summary>\n    /// The stop number for this parcel.\n    /// </summary>\n    public int StopNumber { get; set; }\n}\n",
          "placeholders": [
            "ProjectName"
          ],
          "file_type": null,
          "language": "C#",
          "purpose": "Source file (ParcelValidationResult)",
          "quality_score": null,
          "patterns": [],
          "created_at": "2025-11-18T11:32:25.069391"
        },
        {
          "schema_version": "1.0.0",
          "name": "ConfigurationService.cs.template",
          "original_path": "DeCUK.Mobile.MyDrive/Services/ConfigurationService.cs",
          "template_path": "templates/other/ConfigurationService.cs.template",
          "content": "\ufeffusing ErrorOr;\nusing DeCUK.Mobile.MyDrive.Constants;\nusing DeCUK.Mobile.MyDrive.Entities;\nusing DeCUK.Mobile.MyDrive.Helpers;\nusing DeCUK.Mobile.MyDrive.Payloads;\nusing DeCUK.Mobile.MyDrive.Services.Interfaces;\nusing DeCUK.Mobile.MyDrive.Telemetry;\n\nnamespace {{ProjectName}};\n\npublic class ConfigurationService : IConfigurationService\n{\n    private readonly string _getAllConfigByDateUrl = \"/v1/configuration?id=mydrive.*,myDrive.*,generic.*&date={0}\";\n    \n    private readonly IXApiKeyApiClientService _apiClient;\n    private readonly ISettingsService _settingsService;\n    private readonly IAppLogger _appLogger;\n    \n    public ConfigurationService(\n        IXApiKeyApiClientService apiClient,\n        ISettingsService settingsService,\n        IAppLogger appLogger)\n    {\n        _apiClient = apiClient;\n        _settingsService = settingsService;\n        _appLogger = appLogger;\n    }\n\n    public async Task<ErrorOr<ConfigurationPayload>> GetConfigurationAsync()\n    {\n        try\n        {\n            var result = await _apiClient.GetAsync<ConfigurationPayload>(new ApiData { Url = BuildConfigUrl() }, nameof(GetConfigurationAsync));\n\n            // API client returns null on errors (non-success status codes, exceptions, or NoContent)\n            // We need to check for null and return an appropriate error\n            if (result == null)\n            {\n                return Error.Failure(\n                    code: \"Configuration.DownloadFailed\",\n                    description: \"Failed to download configuration. The API returned no data or an error. Please check your network connection and authentication, then try again.\");\n            }\n\n            return result;\n        }\n        catch (Exception ex)\n        {\n            return Error.Failure(\"Configuration.ApiError\", $\"Configuration fetch failed: {ex.Message}\");\n        }\n    }\n\n    private string BuildConfigUrl()\n    {\n        var lastDownloadDate = _settingsService.Get(MyDriveConstants.CONFIGDOWNLOADDATE, new DateTime(2000, 1, 1).ToString(\"yyyy-MM-dd\"));\n\n        _appLogger.TrackEvent(EventConstants.CONFIGURATIONSERVICE, new Dictionary<string, string>\n                {\n                    { EventItem.ACTION, \"BuildConfigUrl\" },\n                    { EventItem.STATUSCODE, lastDownloadDate }\n                });\n\n        return string.Format(_getAllConfigByDateUrl, lastDownloadDate);\n    }\n}",
          "placeholders": [
            "ProjectName"
          ],
          "file_type": null,
          "language": "C#",
          "purpose": "Source file (ConfigurationService)",
          "quality_score": null,
          "patterns": [
            "Result type pattern",
            "Async/await"
          ],
          "created_at": "2025-11-18T11:32:25.069486"
        },
        {
          "schema_version": "1.0.0",
          "name": "ConfigurationEngine.cs.template",
          "original_path": "DeCUK.Mobile.MyDrive/Engines/ConfigurationEngine.cs",
          "template_path": "templates/other/ConfigurationEngine.cs.template",
          "content": "\ufeffusing ErrorOr;\nusing DeCUK.Mobile.MyDrive.Constants;\nusing DeCUK.Mobile.MyDrive.Engines.Interfaces;\nusing DeCUK.Mobile.MyDrive.Repositories.Interfaces;\nusing DeCUK.Mobile.MyDrive.Entities;\nusing DeCUK.Mobile.MyDrive.Mapper;\nusing DeCUK.Mobile.MyDrive.Payloads;\nusing DeCUK.Mobile.MyDrive.Services.Interfaces;\nusing DeCUK.Mobile.MyDrive.Telemetry;\n\nnamespace {{ProjectName}};\n\npublic class ConfigurationEngine: IConfigurationEngine\n{\n    IConfigurationRepository _configurationRepository;\n    IConfigurationService _configurationService;\n    ISettingsService _settingsService;\n    private readonly IAppLogger _logger;\n\n    public ConfigurationEngine(\n        IConfigurationRepository configurationRepository,\n        IConfigurationService configurationService,\n        ISettingsService settingsService,\n        IAppLogger logger)\n    {\n        _configurationRepository = configurationRepository;\n        _configurationService = configurationService;\n        _settingsService = settingsService;\n        _logger = logger;\n    }\n\n    public async Task<ApiData> GetApiData(string apiConstant)\n    {\n        return await _configurationRepository.GetApiData(apiConstant);\n    }\n\n    public async Task<bool> HasLocalConfigurationAsync()\n    {\n        try\n        {\n            var hasConfig = await _configurationRepository.HasConfigurationDataAsync();\n\n            _logger.LogDebug(\"Local configuration check: HasConfig={HasConfig}\", hasConfig);\n\n            return hasConfig;\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Error checking local configuration\");\n            return false; // Safe default: assume no configuration\n        }\n    }\n\n    public async Task<ErrorOr<bool>> RefreshConfigurationDataAsync()\n    {\n        try\n        {\n            // GET Configuration Data from API\n            var configResult = await _configurationService.GetConfigurationAsync();\n            if (configResult.IsError)\n            {\n                _logger.LogWarning(\"Configuration download failed: {ErrorCode}\", configResult.FirstError.Code);\n                return configResult.Errors;\n            }\n\n            var configPayload = configResult.Value;\n\n            // Validate payload has data\n            if (configPayload?.data == null)\n            {\n                _logger.LogWarning(\"Configuration payload is null or contains no data\");\n                return Error.Validation(\n                    \"Configuration.EmptyPayload\",\n                    \"Configuration payload is empty or null\");\n            }\n\n            _logger.LogDebug(\"Configuration downloaded successfully, processing {Count} configuration items\",\n                configPayload.data.Length);\n\n            // Translate Payload to Entity\n            var processedConfigurationData = ProcessConfigurationData(configPayload.data);\n\n            // Store Configuration Data to DB\n            bool updatedSuccessfully = await _configurationRepository.UpdateAllConfigurationDataAsync(\n                processedConfigurationData.Item1,\n                processedConfigurationData.Item2,\n                processedConfigurationData.Item3,\n                processedConfigurationData.Item4);\n\n            if (!updatedSuccessfully)\n            {\n                _logger.LogWarning(\"Failed to update configuration data in repository\");\n                return Error.Failure(\n                    \"Configuration.UpdateFailed\",\n                    \"Failed to persist configuration data to database\");\n            }\n\n            // Update Settings to save new \"Last retrieved date\"\n            _settingsService.Save(MyDriveConstants.CONFIGDOWNLOADDATE, DateTime.UtcNow.ToString(\"yyyy-MM-dd\"));\n            _logger.LogInformation(\"Configuration refresh completed successfully\");\n            return true;\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Unexpected error during configuration refresh: {ErrorMessage}\", ex.Message);\n            return Error.Unexpected(\n                \"Configuration.UnexpectedError\",\n                $\"An unexpected error occurred while refreshing configuration: {ex.Message}\");\n        }\n    }\n\n    public Tuple<List<ConfigurationDiscrepancy>, List<Entities.ConfigurationItem>, List<ConfigurationJobAttempt>, List<ConfigurationJobOfferResponse>> ProcessConfigurationData(IEnumerable<ConfigurationData> configurationData)\n    {\n        if (configurationData == null)\n        {\n            throw new ArgumentNullException(nameof(configurationData), \"Configuration data cannot be null\");\n        }\n\n        List<ConfigurationDiscrepancy> configurationDiscrepancies = new List<ConfigurationDiscrepancy>();\n        List<Entities.ConfigurationItem> configurationItems = new List<Entities.ConfigurationItem>();\n        List<ConfigurationJobAttempt> configurationJobAttempts = new List<ConfigurationJobAttempt>();\n        List<ConfigurationJobOfferResponse> configurationJobOfferResponses = new List<ConfigurationJobOfferResponse>();\n\n        var mapper = new ConfigurationTypesMapper();\n\n        foreach (var data in configurationData)\n        {\n            // Skip null data entries\n            if (data?.attributes?.items == null)\n            {\n                _logger.LogWarning(\"Skipping configuration data entry with null attributes or items\");\n                continue;\n            }\n\n            foreach (var item in data.attributes.items)\n            {\n                if (item == null)\n                {\n                    _logger.LogWarning(\"Skipping null configuration item in data id: {DataId}\", data.id);\n                    continue;\n                }\n\n                switch (data.id)\n                {\n                    case ConfigurationConstants.JOBATTEMPTTYPES:\n                        configurationJobAttempts.Add(mapper.ConfigurationItemPayloadToConfigurationJobAttempt(item, data.id));\n                        break;\n                    case ConfigurationConstants.JOBOFFERRESPONSETYPES:\n                        configurationJobOfferResponses.Add(mapper.ConfigurationItemPayloadToConfigurationJobOfferResponse(item, data.id));\n                        break;\n                    case ConfigurationConstants.DISCREPANCYDAMAGEDOPTIONS:\n                        configurationDiscrepancies.Add(mapper.ConfigurationItemPayloadToConfigurationDiscrepancy(item, data.id));\n                        break;\n                    default:\n                        configurationItems.Add(mapper.ConfigurationItemPayloadToConfigurationItem(item, data.id));\n                        break;\n                }\n            }\n        }\n\n        return Tuple.Create(configurationDiscrepancies, configurationItems, configurationJobAttempts, configurationJobOfferResponses);\n    }\n}",
          "placeholders": [
            "ProjectName"
          ],
          "file_type": null,
          "language": "C#",
          "purpose": "Source file (ConfigurationEngine)",
          "quality_score": null,
          "patterns": [
            "Result type pattern",
            "Async/await",
            "Repository pattern"
          ],
          "created_at": "2025-11-18T11:32:25.069595"
        },
        {
          "schema_version": "1.0.0",
          "name": "IConfigurationService.cs.template",
          "original_path": "DeCUK.Mobile.MyDrive/Services/Interfaces/IConfigurationService.cs",
          "template_path": "templates/other/IConfigurationService.cs.template",
          "content": "\ufeffusing ErrorOr;\nusing DeCUK.Mobile.MyDrive.Payloads;\n\nnamespace {{ProjectName}};\n\npublic interface IConfigurationService\n{    \n    Task<ErrorOr<ConfigurationPayload>> GetConfigurationAsync();\n}\n",
          "placeholders": [
            "ProjectName"
          ],
          "file_type": null,
          "language": "C#",
          "purpose": "Source file (IConfigurationService)",
          "quality_score": null,
          "patterns": [
            "Result type pattern",
            "Interface-based abstraction"
          ],
          "created_at": "2025-11-18T11:32:25.069644"
        },
        {
          "schema_version": "1.0.0",
          "name": "ConfigurationPayload.cs.template",
          "original_path": "DeCUK.Mobile.MyDrive/Payloads/ConfigurationPayload.cs",
          "template_path": "templates/other/ConfigurationPayload.cs.template",
          "content": "\ufeffnamespace {{ProjectName}};\n\npublic class ConfigurationPayload\n{\n    public ConfigurationData[] data { get; set; }\n}\n\npublic class ConfigurationData\n{\n    public string type { get; set; }\n    public string id { get; set; }\n    public ConfigurationAttributes attributes { get; set; }\n    public ConfigurationMeta meta { get; set; }\n}\n\npublic class ConfigurationAttributes\n{\n    public string description { get; set; }\n    public ConfigurationItem[] items { get; set; }\n}\n\npublic class ConfigurationItem\n{\n    public bool isDelivery { get; set; }\n    public bool isCollection { get; set; }\n    public string code { get; set; }\n    public string description { get; set; }\n    public int sortOrder { get; set; }\n    public bool isActive { get; set; }\n    public string displayText { get; set; }\n    public string failurePrompt { get; set; }\n    public string[] jobTypes { get; set; }\n    public string[] deliveryTypes { get; set; }\n    public bool? requiresSignature { get; set; }\n    public bool? requiresComment { get; set; }\n    public string commentPrompt { get; set; }\n    public int allowIncomplete { get; set; }\n    public int allowEarly { get; set; }\n    public bool requiresStoreID { get; set; }\n    public bool isSuccess { get; set; }\n    public bool requiresCard { get; set; }\n    public bool requiredPoid { get; set; }\n    public string alternativeConsignmentCode { get; set; }\n    public bool? requiredPhoto { get; set; }\n    public string swapoutDeliveryFailureCode { get; set; }\n    public bool requiresAdditionalComment1 { get; set; }\n    public string additionalComment1Prompt { get; set; }\n    public bool requiresAdditionalComment2 { get; set; }\n    public string additionalComment2Prompt { get; set; }\n    public string responseCode { get; set; }\n    public string rejectionCode { get; set; }\n    public bool requiresName { get; set; }\n    public string namePrompt { get; set; }\n    public bool requiresPin { get; set; }\n    public bool requiresAge { get; set; }\n    public string consignmentCodeId { get; set; }\n    public ConfigurationMeta meta { get; set; }\n}\n\npublic class ConfigurationMeta\n{\n    public DateTime lastUpdated { get; set; }\n}",
          "placeholders": [
            "ProjectName"
          ],
          "file_type": null,
          "language": "C#",
          "purpose": "Source file (ConfigurationPayload)",
          "quality_score": null,
          "patterns": [],
          "created_at": "2025-11-18T11:32:25.069706"
        },
        {
          "schema_version": "1.0.0",
          "name": "AppErrors.cs.template",
          "original_path": "DeCUK.Mobile.MyDrive/Core/Models/AppErrors.cs",
          "template_path": "templates/other/AppErrors.cs.template",
          "content": "using ErrorOr;\n\nnamespace {{ProjectName}};\n\n/// <summary>\n/// Centralized strongly-typed error definitions for the application.\n/// Provides compile-time safety and consistency for error handling.\n/// </summary>\n/// <remarks>\n/// Usage:\n/// <code>\n/// // In services/repositories/engines\n/// return AppErrors.Driver.FetchFailed;\n///\n/// // In ViewModels for user-friendly messages\n/// private string GetUserFriendlyErrorMessage(Error error)\n/// {\n///     if (error == AppErrors.Driver.FetchFailed)\n///         return Strings.ErrorDriverFetchFailed;\n///     // ...\n/// }\n/// </code>\n/// </remarks>\npublic static class AppErrors\n{\n    /// <summary>\n    /// Driver-related errors for DriverEngine, DriverService, and DriverRepository.\n    /// </summary>\n    public static class Driver\n    {\n        // ========== API/Service Errors ==========\n\n        public static readonly Error FetchFailed = Error.Failure(\n            code: \"Driver.Fetch.Failed\",\n            description: \"Failed to fetch driver details from API\");\n\n        public static readonly Error NotFound = Error.NotFound(\n            code: \"Driver.NotFound\",\n            description: \"Driver not found\");\n\n        public static readonly Error InvalidId = Error.Validation(\n            code: \"Driver.Validation.InvalidId\",\n            description: \"Driver ID is invalid or empty\");\n\n        // ========== Validation Errors ==========\n\n        public static readonly Error NoRoute = Error.Validation(\n            code: \"Driver.Validation.NoRoute\",\n            description: \"Driver must have an assigned route\");\n\n        public static readonly Error NullDetails = Error.Validation(\n            code: \"Driver.Validation.NullDetails\",\n            description: \"Driver details cannot be null\");\n\n        // ========== Persistence Errors ==========\n\n        public static readonly Error PersistenceFailed = Error.Failure(\n            code: \"Driver.Persistence.Failed\",\n            description: \"Failed to save driver details to database\");\n\n        public static readonly Error SaveFailed = Error.Failure(\n            code: \"Driver.Persistence.SaveFailed\",\n            description: \"Failed to save driver to database\");\n\n        public static readonly Error MappingFailed = Error.Failure(\n            code: \"Driver.Mapping.Failed\",\n            description: \"Failed to map driver data\");\n\n        public static readonly Error DatabaseError = Error.Failure(\n            code: \"Driver.Database.Error\",\n            description: \"Database operation failed\");\n\n        public static readonly Error GetAllFailed = Error.Failure(\n            code: \"Driver.GetAll.Failed\",\n            description: \"Failed to retrieve all drivers from database\");\n    }\n\n    /// <summary>\n    /// Loading-related errors for LoadingRepository and RouteRepository.\n    /// </summary>\n    public static class Loading\n    {\n        public static readonly Error WriteFailed = Error.Failure(\n            code: \"Loading.Write.Failed\",\n            description: \"Failed to write loading data to database\");\n\n        public static readonly Error DeleteFailed = Error.Failure(\n            code: \"Loading.Delete.Failed\",\n            description: \"Failed to delete loading data from database\");\n\n        public static readonly Error NullData = Error.Validation(\n            code: \"Loading.Validation.NullData\",\n            description: \"Loading data cannot be null or empty\");\n\n        public static readonly Error MappingFailed = Error.Failure(\n            code: \"Loading.Mapping.Failed\",\n            description: \"Failed to map loading data\");\n\n        public static readonly Error DatabaseError = Error.Failure(\n            code: \"Loading.Database.Error\",\n            description: \"Database operation failed for loading data\");\n    }\n\n    /// <summary>\n    /// Planning-related errors for PlanningRepository.\n    /// </summary>\n    public static class Planning\n    {\n        public static readonly Error NullData = Error.Validation(\n            code: \"Planning.Validation.NullData\",\n            description: \"Planning data cannot be null or empty\");\n\n        public static readonly Error MappingFailed = Error.Failure(\n            code: \"Planning.Mapping.Failed\",\n            description: \"Failed to map Planning entities to Realm entities\");\n\n        public static readonly Error WriteFailed = Error.Failure(\n            code: \"Planning.Write.Failed\",\n            description: \"Failed to write Planning data to database\");\n\n        public static readonly Error DeleteFailed = Error.Failure(\n            code: \"Planning.Delete.Failed\",\n            description: \"Failed to delete Planning data from database\");\n    }\n\n    /// <summary>\n    /// Configuration-related errors for ConfigurationEngine and ConfigurationService.\n    /// </summary>\n    public static class Configuration\n    {\n        public static readonly Error DownloadFailed = Error.Failure(\n            code: \"Configuration.Download.Failed\",\n            description: \"Configuration download failed\");\n\n        public static readonly Error ApiError = Error.Failure(\n            code: \"Configuration.Api.Error\",\n            description: \"API error occurred during configuration fetch\");\n\n        public static readonly Error NotFound = Error.NotFound(\n            code: \"Configuration.NotFound\",\n            description: \"Configuration not found\");\n\n        public static readonly Error InvalidFormat = Error.Validation(\n            code: \"Configuration.Validation.InvalidFormat\",\n            description: \"Configuration format is invalid\");\n    }\n\n    /// <summary>\n    /// Authentication-related errors for AuthenticationEngine and related services.\n    /// </summary>\n    public static class Authentication\n    {\n        public static readonly Error InvalidCredentials = Error.Validation(\n            code: \"Authentication.Validation.InvalidCredentials\",\n            description: \"Username or password is invalid\");\n\n        public static readonly Error InvalidUsername = Error.Validation(\n            code: \"Authentication.Validation.InvalidUsername\",\n            description: \"Username is invalid or empty\");\n\n        public static readonly Error InvalidPassword = Error.Validation(\n            code: \"Authentication.Validation.InvalidPassword\",\n            description: \"Password is invalid or empty\");\n\n        public static readonly Error EmptyToken = Error.Failure(\n            code: \"Authentication.EmptyToken\",\n            description: \"Authentication token is empty\");\n\n        public static readonly Error Timeout = Error.Failure(\n            code: \"Authentication.Timeout\",\n            description: \"Authentication request timed out\");\n\n        public static readonly Error Failed = Error.Failure(\n            code: \"Authentication.Failed\",\n            description: \"Authentication failed\");\n\n        public static readonly Error TokenExpired = Error.Unauthorized(\n            code: \"Authentication.TokenExpired\",\n            description: \"Authentication token has expired\");\n\n        public static readonly Error Unauthorized = Error.Unauthorized(\n            code: \"Authentication.Unauthorized\",\n            description: \"User is not authorized\");\n    }\n\n    /// <summary>\n    /// Token-related errors for JWT and authentication token processing.\n    /// </summary>\n    public static class Token\n    {\n        public static readonly Error MalformedToken = Error.Validation(\n            code: \"Token.Validation.MalformedToken\",\n            description: \"Authentication token is malformed or invalid\");\n\n        public static readonly Error ExpiredToken = Error.Unauthorized(\n            code: \"Token.ExpiredToken\",\n            description: \"Authentication token has expired\");\n\n        public static readonly Error MissingDriverId = Error.Validation(\n            code: \"Token.Validation.MissingDriverId\",\n            description: \"Token is missing required driver ID claim\");\n\n        public static readonly Error MissingRouteId = Error.Validation(\n            code: \"Token.Validation.MissingRouteId\",\n            description: \"Token is missing required route ID claim\");\n    }\n\n    /// <summary>\n    /// Route-related errors for RouteEngine and RouteService.\n    /// </summary>\n    public static class Route\n    {\n        public static readonly Error DownloadFailed = Error.Failure(\n            code: \"Route.Download.Failed\",\n            description: \"Failed to download route data\");\n\n        public static readonly Error NotFound = Error.NotFound(\n            code: \"Route.NotFound\",\n            description: \"Route not found\");\n\n        public static readonly Error InvalidData = Error.Validation(\n            code: \"Route.Validation.InvalidData\",\n            description: \"Route data is invalid\");\n\n        public static readonly Error InvalidRouteId = Error.Validation(\n            code: \"Route.Validation.InvalidRouteId\",\n            description: \"Route ID is invalid or empty\");\n\n        public static readonly Error NoItems = Error.Validation(\n            code: \"Route.Validation.NoItems\",\n            description: \"Route contains no items\");\n\n        public static readonly Error PersistenceFailed = Error.Failure(\n            code: \"Route.Persistence.Failed\",\n            description: \"Failed to save route to database\");\n    }\n\n    /// <summary>\n    /// General application errors that don't fit specific domains.\n    /// </summary>\n    public static class General\n    {\n        public static readonly Error UnknownError = Error.Failure(\n            code: \"General.UnknownError\",\n            description: \"An unknown error occurred\");\n\n        public static readonly Error NetworkError = Error.Failure(\n            code: \"General.Network.Error\",\n            description: \"Network connection error\");\n\n        public static readonly Error Timeout = Error.Failure(\n            code: \"General.Timeout\",\n            description: \"Operation timed out\");\n\n        public static readonly Error OperationCancelled = Error.Failure(\n            code: \"General.OperationCancelled\",\n            description: \"Operation was cancelled\");\n    }\n}\n",
          "placeholders": [
            "ProjectName"
          ],
          "file_type": null,
          "language": "C#",
          "purpose": "Source file (AppErrors)",
          "quality_score": null,
          "patterns": [
            "Repository pattern",
            "MVVM"
          ],
          "created_at": "2025-11-18T11:32:25.069804"
        },
        {
          "schema_version": "1.0.0",
          "name": "DomainCameraView.cs.template",
          "original_path": "DeCUK.Mobile.MyDrive/Controls/DomainCameraView.cs",
          "template_path": "templates/other/DomainCameraView.cs.template",
          "content": "namespace {{ProjectName}};\n\nusing BarcodeScanning;\nusing DeCUK.Mobile.MyDrive.Core.Models;\nusing DeCUK.Mobile.MyDrive.Core.Interfaces;\nusing DeCUK.Mobile.MyDrive.Engines.Interfaces;\nusing Microsoft.Extensions.DependencyInjection;\n\n/// <summary>\n/// Custom control that bridges the UI BarcodeScanning library with our domain model.\n/// This is the ONLY place that references both UI and domain types.\n/// </summary>\npublic class DomainCameraView : ContentView\n{\n    private readonly CameraView _cameraView;\n    private readonly IScanningEngine? _scanningEngine;\n    private ICameraScannerEngine? _cameraEngine;\n\n    public static readonly BindableProperty IsScanningEnabledProperty =\n        BindableProperty.Create(\n            nameof(IsScanningEnabled),\n            typeof(bool),\n            typeof(DomainCameraView),\n            true,\n            propertyChanged: OnIsScanningEnabledChanged);\n\n    public static readonly BindableProperty IsTorchOnProperty =\n        BindableProperty.Create(\n            nameof(IsTorchOn),\n            typeof(bool),\n            typeof(DomainCameraView),\n            false,\n            propertyChanged: OnIsTorchOnChanged);\n\n    public bool IsScanningEnabled\n    {\n        get => (bool)GetValue(IsScanningEnabledProperty);\n        set => SetValue(IsScanningEnabledProperty, value);\n    }\n\n    public bool IsTorchOn\n    {\n        get => (bool)GetValue(IsTorchOnProperty);\n        set => SetValue(IsTorchOnProperty, value);\n    }\n\n    public DomainCameraView()\n    {\n        System.Diagnostics.Debug.WriteLine($\"DomainCameraView constructor called - Platform: {Microsoft.Maui.Devices.DeviceInfo.Platform}\");\n\n        try\n        {\n            // Get the scanning engine from DI using the current service provider\n            var serviceProvider = IPlatformApplication.Current?.Services;\n            _scanningEngine = serviceProvider?.GetService<IScanningEngine>();\n            System.Diagnostics.Debug.WriteLine($\"DomainCameraView: IScanningEngine = {(_scanningEngine != null ? \"found\" : \"null\")}\");\n\n            _cameraView = new CameraView\n            {\n                ViewfinderMode = true,\n                AimMode = false, // Disabled - we use custom red line overlay\n                CaptureQuality = CaptureQuality.High,\n                BarcodeSymbologies = BarcodeFormats.Code128 | BarcodeFormats.Pdf417 | BarcodeFormats.QRCode\n            };\n\n            // Set up the bridge between UI detection and domain model\n            _cameraView.OnDetectionFinishedCommand = new Command<IReadOnlySet<BarcodeResult>>(\n                ProcessDetection);\n\n            // Create Grid layout with CameraView and red line overlay\n            var grid = new Grid\n            {\n                HorizontalOptions = LayoutOptions.FillAndExpand,\n                VerticalOptions = LayoutOptions.FillAndExpand\n            };\n\n            // CameraView takes full grid\n            _cameraView.SetValue(Grid.RowProperty, 0);\n            _cameraView.SetValue(Grid.ColumnProperty, 0);\n            grid.Children.Add(_cameraView);\n\n            // Red horizontal line overlay with multiple approaches\n            var redLine = CreateRedLineOverlay();\n            redLine.SetValue(Grid.RowProperty, 0);\n            redLine.SetValue(Grid.ColumnProperty, 0);\n            grid.Children.Add(redLine);\n\n            Content = grid;\n        }\n        catch (Exception ex)\n        {\n            System.Diagnostics.Debug.WriteLine($\"DomainCameraView constructor failed: {ex}\");\n            throw;\n        }\n    }\n\n    /// <summary>\n    /// Creates a red line overlay using Border control for cross-platform consistency\n    /// </summary>\n    private View CreateRedLineOverlay()\n    {\n        // Unified Border approach for both iOS and Android\n        var redLineBorder = new Border\n        {\n            Stroke = Colors.Red,\n            StrokeThickness = 0, // No stroke outline, just filled background\n            Background = Colors.Red,\n            HeightRequest = 3,\n            VerticalOptions = LayoutOptions.Center,\n            HorizontalOptions = LayoutOptions.FillAndExpand,\n            InputTransparent = true,\n            IsVisible = true,\n            Opacity = DeviceInfo.Platform == DevicePlatform.iOS ? 0.9 : 0.6, // Slightly higher opacity for iOS visibility\n            Margin = new Thickness(10, 0, 10, 0) // Small margin for better edge visibility\n        };\n\n        // Add subtle shadow on iOS for better camera contrast\n        if (DeviceInfo.Platform == DevicePlatform.iOS)\n        {\n            redLineBorder.Shadow = new Shadow\n            {\n                Brush = Colors.Black,\n                Offset = new Point(0, 1),\n                Radius = 1,\n                Opacity = 0.3f\n            };\n        }\n\n        System.Diagnostics.Debug.WriteLine($\"DomainCameraView: Created unified Border red line for {DeviceInfo.Platform} - Height: {redLineBorder.HeightRequest}, Opacity: {redLineBorder.Opacity}\");\n        return redLineBorder;\n    }\n\n    protected override void OnBindingContextChanged()\n    {\n        base.OnBindingContextChanged();\n\n        // Get camera engine reference if available\n        _cameraEngine = _scanningEngine?.ActiveScanner as ICameraScannerEngine;\n    }\n\n    private void ProcessDetection(IReadOnlySet<BarcodeResult> results)\n    {\n        if (!results.Any())\n        {\n            return;\n        }\n\n        // Try to get camera engine if not available yet\n        if (_cameraEngine == null)\n        {\n            _cameraEngine = _scanningEngine?.ActiveScanner as ICameraScannerEngine;\n            System.Diagnostics.Debug.WriteLine($\"DomainCameraView: Camera engine resolved - {(_cameraEngine != null ? \"success\" : \"still null\")}\");\n        }\n\n        if (_cameraEngine == null)\n        {\n            System.Diagnostics.Debug.WriteLine(\"DomainCameraView: Camera engine still null, cannot process detection\");\n            return;\n        }\n\n        var first = results.First();\n\n        // Convert UI type to domain call\n        _cameraEngine.ProcessCameraDetection(\n            first.RawValue ?? string.Empty,\n            first.BarcodeType.ToString(),\n            null); // BarcodeResult doesn't have a Confidence property\n    }\n\n    private static void OnIsScanningEnabledChanged(BindableObject bindable, object oldValue, object newValue)\n    {\n        if (bindable is DomainCameraView control)\n        {\n            control._cameraView.CameraEnabled = (bool)newValue;\n            control._cameraView.PauseScanning = !(bool)newValue;\n        }\n    }\n\n    private static void OnIsTorchOnChanged(BindableObject bindable, object oldValue, object newValue)\n    {\n        if (bindable is DomainCameraView control)\n        {\n            control._cameraView.TorchOn = (bool)newValue;\n        }\n    }\n}",
          "placeholders": [
            "ProjectName"
          ],
          "file_type": null,
          "language": "C#",
          "purpose": "Source file (DomainCameraView)",
          "quality_score": null,
          "patterns": [],
          "created_at": "2025-11-18T11:32:25.069886"
        },
        {
          "schema_version": "1.0.0",
          "name": "ScanAsyncDataService.cs.template",
          "original_path": "DeCUK.Mobile.MyDrive/AsyncDataServices/ScanAsyncDataService.cs",
          "template_path": "templates/other/ScanAsyncDataService.cs.template",
          "content": "using ErrorOr;\nusing DeCUK.Mobile.MyDrive.AsyncDataServices.Interfaces;\nusing DeCUK.Mobile.MyDrive.Constants;\nusing DeCUK.Mobile.MyDrive.Database;\nusing DeCUK.Mobile.MyDrive.Repositories.Interfaces;\nusing DeCUK.Mobile.MyDrive.Entities;\nusing DeCUK.Mobile.MyDrive.Helpers;\nusing DeCUK.Mobile.MyDrive.Mapper;\nusing DeCUK.Mobile.MyDrive.Payloads;\nusing DeCUK.Mobile.MyDrive.Services;\nusing DeCUK.Mobile.MyDrive.Services.Interfaces;\nusing Microsoft.Extensions.Logging;\n\nnamespace {{ProjectName}};\n\npublic class ScanAsyncDataService : BaseAsyncDataService, IAsyncDataService<Scan>\n{\n    private readonly ILogger<ScanAsyncDataService> _logger;\n    private ScanTypesMapper _mapper = new();\n\n    public ScanAsyncDataService(\n        IApiClientService apiClient,\n        IAsyncController controller,\n        IConfigurationRepository configurationRepository,\n        IDatabaseConfiguration databaseConfiguration,\n        ILogger<ScanAsyncDataService> logger)\n        : base(apiClient, controller, configurationRepository, databaseConfiguration)\n    {\n        _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n        ServiceDataName = \"Scan\";\n    }\n\n    public Guid Create(Scan scanData)\n    {\n        Guid newId = Guid.NewGuid();\n\n        try\n        {\n            RealmScan realmScan = _mapper.ScanToRealmScan(scanData);\n\n            using (var trans = _realm.BeginWrite())\n            {\n                _realm.Add(realmScan);\n\n                trans.Commit();\n            }\n\n            _logger.LogInformation(\"Created scan in queue: {ScanId}\", newId);\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Failed to create scan in queue\");\n            newId = Guid.Empty;\n        }\n\n        return newId;\n    }\n\n    public override List<Guid> GetAll()\n    {\n        List<RealmScan> realmObjects = _realm.All<RealmScan>().ToList();\n\n        List<Guid> ids = new List<Guid>();\n\n        foreach (RealmScan realmObject in realmObjects)\n        {\n            // only process items that have Guid identifiers\n            if (Guid.TryParse(realmObject.Id, out Guid id))\n            {\n                ids.Add(id);\n            }\n        }\n\n        return ids;\n    }\n\n    public override bool Delete(Guid id)\n    {\n        try\n        {\n            RealmScan realmDataObject = _realm.All<RealmScan>().FirstOrDefault(rdo => rdo.Id == id.ToString());\n\n            if (realmDataObject == null)\n            {\n                _logger.LogWarning(\"Cannot delete scan {ScanId} - not found\", id);\n                return false;\n            }\n\n            using (var trans = _realm.BeginWrite())\n            {\n                _realm.Remove(realmDataObject);\n                trans.Commit();\n            }\n\n            _logger.LogInformation(\"Deleted scan from queue: {ScanId}\", id);\n            return true;\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Failed to delete scan {ScanId}\", id);\n            return false;\n        }\n    }\n\n    public bool Exists(Guid id)\n    {\n        throw new NotImplementedException();\n    }\n\n    public Scan Get(Guid id)\n    {\n        throw new NotImplementedException();\n    }\n\n    public List<Scan> GetAllData()\n    {\n        throw new NotImplementedException();\n    }\n\n    public override async Task<ErrorOr<bool>> Send(Guid id)\n    {\n        try\n        {\n            ApiData apiData = await ConfigurationRepository.GetApiData(ApiEndpointConstants.SCAN_POST);\n\n            if (apiData == null)\n            {\n                _logger.LogWarning(\"API endpoint {Endpoint} not found in configuration\", ApiEndpointConstants.SCAN_POST);\n                return Error.NotFound(\"ApiEndpoint.NotFound\", $\"API endpoint {ApiEndpointConstants.SCAN_POST} not found\");\n            }\n\n            RealmScan? realmScan = _realm.All<RealmScan>().Where(rs => rs.Id == id.ToString()).FirstOrDefault();\n\n            if (realmScan == null)\n            {\n                _logger.LogWarning(\"Scan {ScanId} not found in queue\", id);\n                return Error.NotFound(\"Scan.NotFound\", $\"Scan {id} not found in queue\");\n            }\n\n            // Build scan payload using Martin's WIP structure for API compatibility\n            ScanPayload scanPayload = new ScanPayload\n            {\n                data = new Payloads.ScanData\n                {\n                    attributes = new ScanAttributes\n                    {\n                        dateTime = realmScan.ScanTime,\n                        scanType = realmScan.ScanType,\n                        barcode = realmScan.ParcelID,\n                        sourceSystem = realmScan.SourceSystem,\n                        geo = GetGeoCoords(realmScan)\n                    },\n                    relationships = new ScanRelationships\n                    {\n                        device = PayloadHelper.GetBaseRelationship(\"device\", realmScan.ScanDeviceId),\n                        user = PayloadHelper.GetBaseRelationship(\"driver\", realmScan.ScanUserId),\n                        location = PayloadHelper.GetBaseRelationship(\"location\", realmScan.ScanLocationId)\n                    }\n                }\n            };\n\n            var response = await _apiClient.PostAsync<ScanPayload, ScanPayload>(\n                apiData,\n                nameof(Send),\n                scanPayload,\n                Enums.HttpAuthEnum.Driver);\n\n            if (response == null)\n            {\n                _logger.LogError(\"Failed to submit scan {ScanId} - null response from API\", id);\n                return Error.Failure(\"Api.NullResponse\", $\"Failed to submit scan {id} - null response from API\");\n            }\n\n            _logger.LogInformation(\"Successfully submitted scan {ScanId}\", id);\n            return true;\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Exception while sending scan {ScanId}\", id);\n            return Error.Failure(\"Scan.SendException\", $\"Exception while sending scan {id}: {ex.Message}\");\n        }\n    }\n\n    public bool Update(Scan updatedData)\n    {\n        throw new NotImplementedException();\n    }\n\n    /// <summary>\n    /// Helper method to construct GeoCoords from RealmScan location data\n    /// </summary>\n    private GeoCoords GetGeoCoords(RealmScan scan)\n    {\n        if (!scan.Latitude.HasValue)\n        {\n            return new GeoCoords();\n        }\n\n        return new GeoCoords\n        {\n            accuracy = scan.Accuracy,\n            latitude = scan.Latitude,\n            longitude = scan.Longitude,\n            dateTime = scan.LocationTimeStamp.HasValue\n                ? scan.LocationTimeStamp.Value.LocalDateTime.ToString(\"o\")\n                : DateTimeOffset.Now.LocalDateTime.ToString(\"o\")\n        };\n    }\n}\n",
          "placeholders": [
            "ProjectName"
          ],
          "file_type": null,
          "language": "C#",
          "purpose": "Source file (ScanAsyncDataService)",
          "quality_score": null,
          "patterns": [
            "Result type pattern",
            "Async/await",
            "Repository pattern",
            "MVC"
          ],
          "created_at": "2025-11-18T11:32:25.069962"
        },
        {
          "schema_version": "1.0.0",
          "name": "ConfigurationRepository.cs.template",
          "original_path": "DeCUK.Mobile.MyDrive/Repositories/ConfigurationRepository.cs",
          "template_path": "templates/other/ConfigurationRepository.cs.template",
          "content": "using DeCUK.Mobile.MyDrive.Constants;\nusing DeCUK.Mobile.MyDrive.Database;\nusing DeCUK.Mobile.MyDrive.Repositories.Interfaces;\nusing DeCUK.Mobile.MyDrive.Entities;\nusing DeCUK.Mobile.MyDrive.Extensions;\nusing DeCUK.Mobile.MyDrive.Helpers;\nusing DeCUK.Mobile.MyDrive.Mapper;\nusing DeCUK.Mobile.MyDrive.Services.Interfaces;\nusing DeCUK.Mobile.MyDrive.Telemetry;\nusing Realms;\n\nnamespace {{ProjectName}};\n\npublic class ConfigurationRepository : IConfigurationRepository\n{\n    private readonly Realm _realm;\n    private readonly IDatabaseConfiguration _databaseConfiguration;\n    private readonly IAppLogger _appLogger;\n\n    private Dictionary<string, ApiData> _apiDataDictionary = new();\n\n    private ConfigurationTypesMapper _mapper = new();\n\n    public ConfigurationRepository(\n        IDatabaseConfiguration databaseConfiguration,\n        IAppLogger appLogger)\n    {\n        _databaseConfiguration = databaseConfiguration;\n        _appLogger = appLogger;\n\n        _realm = Realm.GetInstance(_databaseConfiguration.RealmConfiguration);\n    }\n\n    public async Task<ApiData> GetApiData(string apiConstant)\n    {\n        if (_apiDataDictionary.Count == 0)\n        {\n            await PopulateApiDataList();\n        }\n\n        return _apiDataDictionary.ContainsKey(apiConstant) ? _apiDataDictionary[apiConstant].CloneJson() : new();\n    }\n\n    private async Task PopulateApiDataList()\n    {\n        List<ConfigurationItem> endpoints = await GetConfigurationItemsList(ConfigurationConstants.APIENDPOINTS);\n        List<ConfigurationItem> timeouts = await GetConfigurationItemsList(ConfigurationConstants.APITIMEOUTS);\n\n        _apiDataDictionary = new Dictionary<string, ApiData>();\n\n        foreach (ConfigurationItem endpoint in endpoints)\n        {\n            if (!_apiDataDictionary.ContainsKey(endpoint.Code))\n            {\n                ConfigurationItem? timeout = timeouts.Where(t => t.Code == endpoint.Code).FirstOrDefault();\n\n                int timeoutValue = AppEnvironment.DEFAULT_TIMEOUT;\n\n                if (timeout != null)\n                    if (int.TryParse(timeout.Description, out timeoutValue))\n                        timeoutValue = timeoutValue * 1000;\n\n                _apiDataDictionary.Add(endpoint.Code, new ApiData { Url = endpoint.Description, Timeout = timeoutValue });\n            }\n        }\n    }\n\n    public Task<List<ConfigurationItem>> GetConfigurationItemsList(string configurationItemType)\n    {\n        List<RealmConfigItem> realmConfigItemList = _realm.All<RealmConfigItem>().Where(c => c.ConfigurationType == configurationItemType).ToList();\n\n        return Task.FromResult(_mapper.RealmConfigItemToConfigurationItem(realmConfigItemList));\n    }\n\n    public Task<bool> HasConfigurationDataAsync()\n    {\n        try\n        {\n            // Use Any() for better performance than Count()\n            var hasData = _realm.All<RealmConfigItem>().Any();\n            return Task.FromResult(hasData);\n        }\n        catch (Exception ex)\n        {\n            _appLogger.LogError(ex, \"Error checking configuration data existence\");\n            return Task.FromResult(false); // Safe default: assume no configuration\n        }\n    }\n\n    public async Task<bool> UpdateAllConfigurationDataAsync(List<ConfigurationDiscrepancy> configurationDiscrepancies, List<ConfigurationItem> configurationItems, List<ConfigurationJobAttempt> configurationJobAttempts, List<ConfigurationJobOfferResponse> configurationJobOfferResponses)\n    {\n        List<RealmConfigDiscrepOption> realmConfigDiscrepOptions = _mapper.ConfigurationDiscrepancyToRealmConfigDiscrepOption(configurationDiscrepancies);\n        List<RealmConfigItem> realmConfigTypes = _mapper.ConfigurationItemToRealmConfigItem(configurationItems);\n        List<RealmConfigJobAttempt> realmConfigJobAttempts = _mapper.ConfigurationJobAttemptToRealmConfigJobAttempt(configurationJobAttempts);\n        List<RealmConfigJobOfferResponse> realmConfigJobOfferResponses = _mapper.ConfigurationJobOfferResponseToRealmConfigJobOfferResponse(configurationJobOfferResponses);\n\n        var tasks = new[]\n{\n            SaveEntities(realmConfigTypes, (item) => _realm.All<RealmConfigItem>().FirstOrDefault(ct => ct.ConfigurationType == item.ConfigurationType && ct.Code == item.Code)),\n            SaveEntities(realmConfigDiscrepOptions, (item) => _realm.All<RealmConfigDiscrepOption>().FirstOrDefault(ct => ct.ConfigurationType == item.ConfigurationType && ct.Description == item.Description)),\n            SaveEntities(realmConfigJobOfferResponses, (item) => _realm.All<RealmConfigJobOfferResponse>().FirstOrDefault(ct => ct.ConfigurationType == item.ConfigurationType && ct.DisplayText == item.DisplayText)),\n            SaveEntities(realmConfigJobAttempts, (item) => _realm.All<RealmConfigJobAttempt>().FirstOrDefault(ct => ct.ConfigurationType == item.ConfigurationType && ct.ConsignmentCodeId == item.ConsignmentCodeId))\n        };\n\n        var responses = await Task.WhenAll(tasks);\n        return responses.All(success => success);\n    }\n\n    private Task<bool> SaveEntities<T>(List<T> entities, Func<T, T?> findExisting) where T : RealmObject\n    {\n\n        _appLogger.TrackEvent(EventConstants.CONFIGURATIONDATABASESERVICE, new Dictionary<string, string>\n        {\n            { EventItem.ACTION, $\"SaveEntities - Type: {typeof(T).Name}\" },\n            { EventItem.STATUSCODE, entities.Count.ToString() }\n        });\n\n        if (entities.Count == 0) return Task.FromResult(true);\n\n        try\n        {\n            using (var trans = _realm.BeginWrite())\n            {\n                foreach (var entity in entities)\n                {\n                    var existingEntity = findExisting(entity);\n\n                    if (existingEntity != null)\n                    {\n                        if (entity.GetType().GetProperty(\"IsActive\")?.GetValue(entity) is bool isActive && !isActive)\n                        {\n                            _realm.Remove(existingEntity);\n                        }\n                        else\n                        {\n                            _realm.Remove(existingEntity);\n                            _realm.Add(entity);\n                        }\n                    }\n                    else if (entity.GetType().GetProperty(\"IsActive\")?.GetValue(entity) as bool? == true)\n                    {\n                        _realm.Add(entity);\n                    }\n                }\n                trans.Commit();\n            }\n            return Task.FromResult(true);\n        }\n        catch (Exception e)\n        {\n            _appLogger.LogError(e);\n            return Task.FromResult(false);\n        }\n    }\n}\n",
          "placeholders": [
            "ProjectName"
          ],
          "file_type": null,
          "language": "C#",
          "purpose": "Source file (ConfigurationRepository)",
          "quality_score": null,
          "patterns": [
            "Async/await",
            "Repository pattern"
          ],
          "created_at": "2025-11-18T11:32:25.070039"
        },
        {
          "schema_version": "1.0.0",
          "name": "LoadingRepository.cs.template",
          "original_path": "DeCUK.Mobile.MyDrive/Repositories/LoadingRepository.cs",
          "template_path": "templates/other/LoadingRepository.cs.template",
          "content": "using DeCUK.Mobile.MyDrive.Core.Models;\nusing DeCUK.Mobile.MyDrive.Database;\nusing DeCUK.Mobile.MyDrive.Entities;\nusing DeCUK.Mobile.MyDrive.Mapper;\nusing DeCUK.Mobile.MyDrive.Repositories.Interfaces;\nusing DeCUK.Mobile.MyDrive.Telemetry;\nusing ErrorOr;\nusing Realms;\nusing Realms.Exceptions;\n\nnamespace {{ProjectName}};\n\n/// <summary>\n/// Repository for managing loading data with domain entity encapsulation.\n/// Uses mapper pattern to separate domain entities from database objects.\n/// Implements ErrorOr pattern for functional error handling.\n/// </summary>\npublic class LoadingRepository : ILoadingRepository\n{\n    private readonly RealmConfigurationBase _realmConfiguration;\n    private readonly IAppLogger _logger;\n    private readonly LoadingTypesMapper _mapper;\n\n    public LoadingRepository(\n        IDatabaseConfiguration databaseConfiguration,\n        IAppLogger logger,\n        LoadingTypesMapper mapper)\n    {\n        var databaseConfig = databaseConfiguration ?? throw new ArgumentNullException(nameof(databaseConfiguration));\n        _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n        _mapper = mapper ?? throw new ArgumentNullException(nameof(mapper));\n\n        _realmConfiguration = databaseConfig.RealmConfiguration;\n    }\n    \n    public async Task<ErrorOr<bool>> DeleteAsync()\n    {\n        try\n        {\n            // Get Realm instance for the calling thread\n            // This is thread-safe as each thread gets its own instance\n            using var realm = await Realm.GetInstanceAsync(_realmConfiguration);\n\n            // Execute deletion within transaction\n            await realm.WriteAsync(() =>\n            {\n                realm.RemoveAll<RealmLoading>();\n            });\n\n            _logger.LogInformation(\"Deleted all loading items from database\");\n            return true;\n        }\n        catch (RealmException ex)\n        {\n            _logger.LogError(ex, \"Realm exception while deleting loading data from database\");\n            return Error.Failure(\n                code: \"Loading.Database.RealmError\",\n                description: $\"Realm database error during delete: {ex.Message}\");\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Failed to delete loading data from database\");\n            return AppErrors.Loading.DeleteFailed;\n        }\n    }\n    \n    public async Task<ErrorOr<IList<Loading>>> WriteAsync(IList<Loading> loading)\n    {\n        try\n        {\n            // Validate input\n            if (loading == null || !loading.Any())\n            {\n                _logger.LogWarning(\"Write called with null or empty loading data\");\n                return AppErrors.Loading.NullData;\n            }\n\n            // Map to Realm entities\n            List<RealmLoading> realmList = _mapper.LoadingListToRealmLoadingList(loading.ToList());\n\n            // Validate mapper result\n            if (realmList == null)\n            {\n                _logger.LogWarning(\"Mapper returned null for valid Loading list\");\n                return AppErrors.Loading.MappingFailed;\n            }\n\n            // Get Realm instance for the calling thread\n            // This is thread-safe as each thread gets its own instance\n            using var realm = await Realm.GetInstanceAsync(_realmConfiguration);\n\n            // Persist with transaction safety\n            await realm.WriteAsync(() =>\n            {\n                realm.Add(realmList, update: true);\n            });\n\n            _logger.LogInformation(\"Saved {Count} loading items to database\", loading.Count);\n\n            // Return the input data (already in domain entity form)\n            // ErrorOr requires concrete type - convert to List<T> which implements IList<T>\n            return loading.ToList();\n        }\n        catch (RealmException ex)\n        {\n            _logger.LogError(ex, \"Realm exception while writing loading data to database\");\n            return Error.Failure(\n                code: \"Loading.Database.RealmError\",\n                description: $\"Realm database error during write: {ex.Message}\");\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Failed to write loading data to database\");\n            return AppErrors.Loading.WriteFailed;\n        }\n    }\n    \n    public async Task<ErrorOr<List<Loading>>> ReadAsync()\n    {\n        try\n        {\n            // Get Realm instance for the calling thread\n            // This is thread-safe as each thread gets its own instance\n            using var realm = await Realm.GetInstanceAsync(_realmConfiguration);\n\n            // Query all loading items ordered by StopNumber\n            // Materialize immediately with ToList() to prevent deferred execution\n            var realmLoading = realm.All<RealmLoading>()\n                .OrderBy(r => r.StopNumber)\n                .ToList();\n\n            // Check if any data exists\n            if (realmLoading == null || realmLoading.Count == 0)\n            {\n                return Error.NotFound(\n                    code: \"Loading.NoData\",\n                    description: \"No loading data found in the database\");\n            }\n\n            // Map to domain entities\n            // This detaches data from Realm, making it safe for cross-thread usage\n            var loadingList = _mapper.RealmLoadingListToLoadingList(realmLoading);\n\n            // Validate mapper result\n            if (loadingList == null)\n            {\n                _logger.LogWarning(\"Mapper returned null when mapping {Count} RealmLoading items\", realmLoading.Count);\n                return AppErrors.Loading.MappingFailed;\n            }\n\n            _logger.LogInformation(\"Retrieved {Count} loading items from database\", loadingList.Count);\n\n            // Return detached entities - safe for cross-thread usage\n            return loadingList;\n        }\n        catch (RealmException ex)\n        {\n            _logger.LogError(ex, \"Realm exception while reading loading data from database\");\n            return Error.Failure(\n                code: \"Loading.Database.RealmError\",\n                description: $\"Realm database error during read: {ex.Message}\");\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Failed to read loading data from database\");\n            return AppErrors.Loading.DatabaseError;\n        }\n    }\n}\n",
          "placeholders": [
            "ProjectName"
          ],
          "file_type": null,
          "language": "C#",
          "purpose": "Source file (LoadingRepository)",
          "quality_score": null,
          "patterns": [
            "Result type pattern",
            "Async/await",
            "Repository pattern"
          ],
          "created_at": "2025-11-18T11:32:25.070109"
        },
        {
          "schema_version": "1.0.0",
          "name": "LoadingSummaryService.cs.template",
          "original_path": "DeCUK.Mobile.MyDrive/Services/LoadingSummaryService.cs",
          "template_path": "templates/other/LoadingSummaryService.cs.template",
          "content": "using ErrorOr;\nusing DeCUK.Mobile.MyDrive.Entities;\nusing DeCUK.Mobile.MyDrive.Engines.Interfaces;\nusing DeCUK.Mobile.MyDrive.Enums;\nusing DeCUK.Mobile.MyDrive.Services.Interfaces;\nusing DeCUK.Mobile.MyDrive.Telemetry;\n\nnamespace {{ProjectName}};\n\n/// <summary>\n/// Provides loading summary and reporting operations.\n/// Implements ILoadingSummaryProvider interface.\n/// </summary>\n/// <remarks>\n/// Part of LoadingEngine SRP refactoring.\n/// Extracted from LoadingEngine.GetLoadingSummaryAsync and GetPendingParcelsAsync.\n///\n/// Responsibilities:\n/// - Generate loading summaries for routes\n/// - Query pending parcels\n/// - Calculate loading progress metrics\n///\n/// Does NOT contain:\n/// - Business logic (belongs in LoadingEngine)\n/// - Data storage (uses ILoadingDataService)\n/// - Validation (belongs in LoadingEngine)\n/// - Debug tools (belongs in DeveloperToolsService)\n/// </remarks>\npublic class LoadingSummaryService : ILoadingSummaryProvider\n{\n    private readonly ILoadingDataService _dataService;\n    private readonly IAppLogger _logger;\n\n    public LoadingSummaryService(\n        ILoadingDataService dataService,\n        IAppLogger logger)\n    {\n        _dataService = dataService ?? throw new ArgumentNullException(nameof(dataService));\n        _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n    }\n\n    /// <inheritdoc />\n    public async Task<ErrorOr<RouteLoadingSummary>> GetLoadingSummaryAsync(LoadingContext context)\n    {\n        try\n        {\n            // Validate context\n            if (context == null)\n            {\n                return Error.Validation(\n                    \"Loading.ContextRequired\",\n                    \"Loading context is required\");\n            }\n\n            // Get all parcels from data service\n            var itemsResult = await _dataService.GetAllLoadingItemsAsync();\n            if (itemsResult.IsError)\n            {\n                _logger.LogWarning(\n                    \"LoadingSummaryService: Failed to get loading items for summary\");\n                return itemsResult.Errors;\n            }\n\n            var parcels = itemsResult.Value;\n\n            // Calculate summary metrics\n            var summary = new RouteLoadingSummary\n            {\n                RouteId = context.RouteId,\n                TotalParcels = parcels.Count,\n                LoadedParcels = parcels.Count(p => p.Status == LoadStatus.Scanned),\n                PendingParcels = parcels.Count(p => p.Status == LoadStatus.Expected),\n                OutstandingParcels = parcels.Count(p => p.Status == LoadStatus.Outstanding),\n                HighValueCount = parcels.Count(p => p.HighValue),\n                LoadedHighValueCount = parcels.Count(p => p.HighValue && p.Status == LoadStatus.Scanned)\n            };\n\n            _logger.LogDebug(\n                \"LoadingSummaryService: Summary for route {RouteId} - Total={Total}, Loaded={Loaded}, Pending={Pending}\",\n                context.RouteId,\n                summary.TotalParcels,\n                summary.LoadedParcels,\n                summary.PendingParcels);\n\n            // Log performance metrics\n            var progressPercentage = summary.LoadingProgressPercentage;\n            _logger.TrackEvent(\"LoadingProgressCalculated\", new Dictionary<string, string>\n            {\n                { \"RouteId\", context.RouteId },\n                { \"Progress\", progressPercentage.ToString(\"F1\") },\n                { \"TotalParcels\", summary.TotalParcels.ToString() },\n                { \"LoadedParcels\", summary.LoadedParcels.ToString() }\n            });\n\n            if (summary.HighValueCount > 0)\n            {\n                var highValueProgress = (double)summary.LoadedHighValueCount / summary.HighValueCount * 100;\n                _logger.TrackEvent(\"HighValueLoadingProgress\", new Dictionary<string, string>\n                {\n                    { \"RouteId\", context.RouteId },\n                    { \"Progress\", highValueProgress.ToString(\"F1\") },\n                    { \"TotalHighValue\", summary.HighValueCount.ToString() },\n                    { \"LoadedHighValue\", summary.LoadedHighValueCount.ToString() }\n                });\n            }\n\n            return summary;\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(\n                ex,\n                \"LoadingSummaryService: Failed to get loading summary for route {RouteId}\",\n                context?.RouteId ?? \"UNKNOWN\");\n\n            return Error.Failure(\n                \"Loading.SummaryFailed\",\n                $\"Failed to retrieve loading summary: {ex.Message}\");\n        }\n    }\n\n    /// <inheritdoc />\n    public async Task<ErrorOr<List<Loading>>> GetPendingParcelsAsync(LoadingContext context)\n    {\n        try\n        {\n            // Validate context\n            if (context == null)\n            {\n                return Error.Validation(\n                    \"Loading.ContextRequired\",\n                    \"Loading context is required\");\n            }\n\n            // Query pending parcels using data service\n            var pendingResult = await _dataService.GetLoadingItemsAsync(\n                p => p.Status == LoadStatus.Expected);\n\n            if (pendingResult.IsError)\n            {\n                _logger.LogWarning(\n                    \"LoadingSummaryService: Failed to get pending parcels\");\n                return pendingResult.Errors;\n            }\n\n            var pendingParcels = pendingResult.Value;\n\n            _logger.LogDebug(\n                \"LoadingSummaryService: Found {Count} pending parcels for route {RouteId}\",\n                pendingParcels.Count,\n                context.RouteId);\n\n            // Log performance metric\n            _logger.TrackEvent(\"PendingParcelsQueried\", new Dictionary<string, string>\n            {\n                { \"RouteId\", context.RouteId },\n                { \"PendingCount\", pendingParcels.Count.ToString() }\n            });\n\n            return pendingParcels;\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(\n                ex,\n                \"LoadingSummaryService: Failed to get pending parcels\");\n\n            return Error.Failure(\n                \"Loading.QueryFailed\",\n                $\"Failed to retrieve pending parcels: {ex.Message}\");\n        }\n    }\n}\n",
          "placeholders": [
            "ProjectName"
          ],
          "file_type": null,
          "language": "C#",
          "purpose": "Source file (LoadingSummaryService)",
          "quality_score": null,
          "patterns": [
            "Result type pattern",
            "Async/await"
          ],
          "created_at": "2025-11-18T11:32:25.070180"
        },
        {
          "schema_version": "1.0.0",
          "name": "DriverRepository.cs.template",
          "original_path": "DeCUK.Mobile.MyDrive/Repositories/DriverRepository.cs",
          "template_path": "templates/other/DriverRepository.cs.template",
          "content": "\nusing DeCUK.Mobile.MyDrive.Core.Models;\nusing DeCUK.Mobile.MyDrive.Database;\nusing DeCUK.Mobile.MyDrive.Entities;\nusing DeCUK.Mobile.MyDrive.Mapper;\nusing DeCUK.Mobile.MyDrive.Repositories.Interfaces;\nusing DeCUK.Mobile.MyDrive.Telemetry;\nusing ErrorOr;\nusing Realms;\n\nnamespace {{ProjectName}};\n\n/// <summary>\n/// Repository for managing driver data with domain entity encapsulation.\n/// Uses mapper pattern to separate domain entities from database objects.\n/// </summary>\n/// <remarks>\n/// REALM THREAD-SAFETY STRATEGY:\n///\n/// Realm objects are confined to the thread they were created on. This repository\n/// ensures thread safety by:\n///\n/// 1. STORING CONFIGURATION, NOT INSTANCES:\n///    - Stores RealmConfigurationBase instead of Realm instance\n///    - Each method call gets its own Realm instance via GetInstanceAsync\n///    - Instances are properly disposed after use (using var pattern)\n///\n/// 2. DETACHING DATA FROM REALM:\n///    - Never returns Realm objects directly\n///    - All data is mapped to plain C# objects (DriverDetails)\n///    - Mapped objects are safe for cross-thread usage\n///    - No live Realm object references leave the repository\n///\n/// 3. ASYNC OPERATIONS:\n///    - Uses Realm.GetInstanceAsync for thread-safe async initialization\n///    - Allows caller to control execution context\n///    - Compatible with UI thread and background operations\n///\n/// IMPORTANT: Callers can use this repository from any thread, including\n/// background threads, as long as they await the results before using them\n/// on the UI thread.\n/// </remarks>\npublic class DriverRepository : IDriverRepository\n{\n    private readonly IAppLogger _logger;\n    private readonly DriverTypesMapper _mapper;\n    private readonly RealmConfigurationBase _realmConfiguration;\n\n    public DriverRepository(\n        IAppLogger logger,\n        IDatabaseConfiguration databaseHelper,\n        DriverTypesMapper mapper)\n    {\n        _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n        var databaseConfiguration = databaseHelper ?? throw new ArgumentNullException(nameof(databaseHelper));\n        _mapper = mapper ?? throw new ArgumentNullException(nameof(mapper));\n\n        _realmConfiguration = databaseConfiguration.RealmConfiguration;\n    }\n    \n    public async Task<ErrorOr<DriverDetails>> SaveDriver(DriverDetails driverDetails)\n    {\n        try\n        {\n            // Validate input\n            if (driverDetails == null)\n            {\n                _logger.LogWarning(\"SaveDriver called with null driver details\");\n                return AppErrors.Driver.NullDetails;\n            }\n\n            var realmDriver = _mapper.MapToRealmDriver(driverDetails);\n\n            if (realmDriver == null)\n            {\n                _logger.LogWarning(\"Mapper returned null for valid DriverDetails\");\n                return AppErrors.Driver.MappingFailed;\n            }\n\n            // Get Realm instance for the calling thread\n            // This is thread-safe as each thread gets its own instance\n            using var realm = await Realm.GetInstanceAsync(_realmConfiguration);\n\n            // Single transaction with upsert - automatically handles insert or update\n            using (var trans = realm.BeginWrite())\n            {\n                realm.Add(realmDriver, update: true);\n                trans.Commit();\n            }\n\n            _logger.LogInformation(\"Saved driver to database: {BadgeId}\", driverDetails.BadgeID);\n            return driverDetails;\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Failed to save driver to database: {BadgeId}\", driverDetails?.BadgeID);\n            return AppErrors.Driver.SaveFailed;\n        }\n    }\n\n    public async Task Clear()\n    {\n        try\n        {\n            // Get Realm instance for the calling thread\n            // This is thread-safe as each thread gets its own instance\n            using var realm = await Realm.GetInstanceAsync(_realmConfiguration);\n\n            realm.Write(() =>\n            {\n                realm.RemoveAll<RealmDriver>();\n            });\n            _logger.LogInformation(\"Cleared all drivers from database\");\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Failed to clear drivers from database\");\n        }\n    }\n\n    public async Task<ErrorOr<DriverDetails>> GetDriverDetails()\n    {\n        try\n        {\n            // Get Realm instance for the calling thread\n            // This is thread-safe as each thread gets its own instance\n            using var realm = await Realm.GetInstanceAsync(_realmConfiguration);\n\n            // Query driver and materialize with FirstOrDefault() to detach from Realm\n            var realmDriver = realm.All<RealmDriver>().FirstOrDefault();\n\n            if (realmDriver == null)\n            {\n                _logger.LogDebug(\"No driver found in database\");\n                return AppErrors.Driver.NotFound;\n            }\n\n            var driverDetails = _mapper.MapToDriverDetails(realmDriver);\n\n            if (driverDetails == null)\n            {\n                // TODO might be better as LogError but that currently takes an Exception parameter\n                _logger.LogWarning(\"Mapper returned null for valid RealmDriver\");\n                return AppErrors.Driver.MappingFailed;\n            }\n\n            _logger.LogDebug(\"Retrieved driver details from database: {BadgeId}\", driverDetails.BadgeID);\n            return driverDetails;\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"Unexpected error retrieving driver details from database\");\n            return AppErrors.Driver.DatabaseError;\n        }\n    }\n}\n",
          "placeholders": [
            "ProjectName"
          ],
          "file_type": null,
          "language": "C#",
          "purpose": "Source file (DriverRepository)",
          "quality_score": null,
          "patterns": [
            "Result type pattern",
            "Async/await",
            "Repository pattern"
          ],
          "created_at": "2025-11-18T11:32:25.070246"
        },
        {
          "schema_version": "1.0.0",
          "name": "DeCUKBaseApiClientService.cs.template",
          "original_path": "DeCUK.Mobile.MyDrive/Services/DeCUKBaseApiClientService.cs",
          "template_path": "templates/other/DeCUKBaseApiClientService.cs.template",
          "content": "\ufeffusing DeCUK.Mobile.MyDrive.Enums;\nusing System.Net;\nusing DeCUK.Mobile.MyDrive.Constants;\nusing DeCUK.Mobile.MyDrive.Services.Interfaces;\nusing DeCUK.Mobile.MyDrive.Helpers;\nusing DeCUK.Mobile.MyDrive.Entities;\nusing System.Net.Http.Json;\nusing Newtonsoft.Json;\nusing System.Text;\nusing DeCUK.Mobile.MyDrive.Telemetry;\n\nnamespace {{ProjectName}};\n\npublic abstract class DeCUKBaseApiClientService : IApiClientService\n{\n    protected readonly HttpClient _client;\n    protected IAppLogger AppLogger;\n    protected ISettingsService SettingsService;\n\n    public DeCUKBaseApiClientService(\n        HttpClient client,\n        IAppLogger appLogger,\n        ISettingsService settingsService)\n    {\n        _client = client;\n        AppLogger = appLogger;\n        SettingsService = settingsService;\n    }\n\n    public async Task<T> GetAsync<T>(ApiData apiData, string callerName, HttpAuthEnum auth, string acceptType = EnvironmentConstants.JSON_API_MIME_TYPE, Dictionary<string, string> additionalHeaders = null) where T : class\n    {\n        AppLogger.TrackEvent(EventConstants.APICLIENTSERVICE, new Dictionary<string, string>\n            {\n                { EventItem.ACTION, callerName }\n            });\n\n        try\n        {\n            HttpResponseMessage response = await SendAsync(HttpMethod.Get, apiData, auth);\n            if (response.IsSuccessStatusCode)\n            {\n                if (response.StatusCode == HttpStatusCode.NoContent) \n                {\n                    AppLogger.TrackEvent(EventConstants.APICLIENTSERVICE, new Dictionary<string, string>\n                        {\n                            { EventItem.ACTION, string.Format(\"{0} - No content\", callerName) },\n                            { EventItem.STATUSCODE, response?.StatusCode.ToString() ?? \"null\" }\n                        });\n                    return default(T);\n                }\n\n                return await response.Content.ReadFromJsonAsync<T>();\n            }\n            else\n            {\n                string errorMessage = await response.Content?.ReadAsStringAsync();\n\n                AppLogger.TrackEvent(EventConstants.APICLIENTSERVICE, new Dictionary<string, string>\n                {\n                    { EventItem.ACTION, string.Format(\"{0} - Response unsuccessful\", callerName) },\n                    { EventItem.STATUSCODE, response?.StatusCode.ToString() ?? \"null\" },\n                    { EventItem.ERRORMESSAGE, errorMessage }\n                });\n\n                return null;\n            }\n        }\n        catch (Exception ex)\n        {\n            AppLogger.TrackError(ex, new Dictionary<string, string>\n                {\n                    {EventItem.ACTION, callerName }\n                });\n\n            return null;\n        }\n    }\n    public async Task<HttpResponseMessage> PutAsync(ApiData apiData, HttpContent payload, HttpAuthEnum auth)\n    {\n        return await SendAsync(new HttpMethod(\"PUT\"), apiData, auth, payload);\n    }\n\n    public async Task<T2> PostAsync<T1, T2>(ApiData apiData, string callerName, T1 payload, HttpAuthEnum auth = HttpAuthEnum.None) where T1 : class, new() where T2 : class\n    {\n        AppLogger.TrackEvent(EventConstants.APICLIENTSERVICE, new Dictionary<string, string>\n            {\n                { EventItem.ACTION, callerName }\n            });\n\n        try\n        {\n            HttpContent content = new StringContent( JsonConvert.SerializeObject(payload), Encoding.UTF8, EnvironmentConstants.JSON_MIME_TYPE);\n            HttpResponseMessage response = await SendAsync(HttpMethod.Post, apiData, auth, content);\n            if (response.IsSuccessStatusCode)\n            {\n                if (response.StatusCode == HttpStatusCode.NoContent)\n                {\n                    AppLogger.TrackEvent(EventConstants.APICLIENTSERVICE, new Dictionary<string, string>\n                        {\n                            { EventItem.ACTION, string.Format(\"{0} - No content\", callerName) },\n                            { EventItem.STATUSCODE, response?.StatusCode.ToString() ?? \"null\" }\n                        });\n                    return default(T2);\n                }\n\n                return await response.Content.ReadFromJsonAsync<T2>();\n            }\n            else\n            {\n                string errorMessage = await response.Content?.ReadAsStringAsync();\n\n                AppLogger.TrackEvent(EventConstants.APICLIENTSERVICE, new Dictionary<string, string>\n                {\n                    { EventItem.ACTION, string.Format(\"{0} - Response unsuccessful\", callerName) },\n                    { EventItem.STATUSCODE, response?.StatusCode.ToString() ?? \"null\" },\n                    { EventItem.ERRORMESSAGE, errorMessage }\n                });\n\n                return null;\n            }\n        }\n        catch (Exception ex)\n        {\n            AppLogger.TrackError(ex, new Dictionary<string, string>\n                {\n                    {EventItem.ACTION, callerName }\n                });\n\n            return null;\n        }\n    }\n\n    public async Task<HttpResponseMessage> PatchAsync(ApiData apiData, HttpContent payload, HttpAuthEnum auth)\n    {\n        return await SendAsync(new HttpMethod(\"PATCH\"), apiData, auth, payload);\n    }\n\n    public async Task<HttpResponseMessage> DeleteAsync(ApiData apiData, HttpAuthEnum auth)\n    {\n        return await SendAsync(new HttpMethod(\"DELETE\"), apiData, auth);\n    }\n\n    protected abstract Task<HttpResponseMessage> SendAsync(HttpMethod method, ApiData apiData, HttpAuthEnum auth, HttpContent payload = null, string acceptType = EnvironmentConstants.JSON_API_MIME_TYPE, Dictionary<string, string> additionalHeaders = null);\n}",
          "placeholders": [
            "ProjectName"
          ],
          "file_type": null,
          "language": "C#",
          "purpose": "Source file (DeCUKBaseApiClientService)",
          "quality_score": null,
          "patterns": [
            "Async/await"
          ],
          "created_at": "2025-11-18T11:32:25.070343"
        }
      ],
      "generated_at": "2025-11-18T11:32:25.070370"
    },
    "agent_inventory": null,
    "agents": null
  },
  "agent_request_pending": null
}